<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Canadian Salad Scorekeeper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <style>
    :root {
      --bg: #050816;
      --bg-soft: #0c1224;
      --card: #111827;
      --card-soft: #1f2937;
      --accent: #f97316;
      --accent-soft: rgba(249, 115, 22, 0.14);
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --border-subtle: #1f2933;
      --winner-glow: 0 0 0 2px rgba(52, 211, 153, 0.7);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 50%, #000 100%);
      color: var(--text-main);
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 1rem 0.75rem 2.5rem;
      padding-top: calc(1rem + env(safe-area-inset-top));
      padding-bottom: calc(2.5rem + env(safe-area-inset-bottom));
    }

    header { text-align: center; margin-bottom: 0.5rem; }

    header h1 {
      margin: 0;
      font-size: 1.5rem;
      letter-spacing: 0.05em;
    }

    header p {
      margin: 0.35rem 0 0;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .card {
      background: linear-gradient(135deg, rgba(15,23,42,0.96), rgba(17,24,39,0.96));
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,0.15);
      box-shadow: 0 18px 40px rgba(15,23,42,0.65);
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      backdrop-filter: blur(14px);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: space-between;
    }

    .controls-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    .controls label { font-size: 0.8rem; color: var(--text-muted); }

    .controls input[type="number"] {
      width: 4rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.6rem;
      border: 1px solid var(--border-subtle);
      background: #020617;
      color: var(--text-main);
      font-size: 0.9rem;
      text-align: center;
      touch-action: manipulation;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      background: radial-gradient(circle at top left, #fb923c, #f97316);
      color: #111827;
      box-shadow: 0 10px 25px rgba(249,115,22,0.4);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      cursor: pointer;
    }

    button.secondary {
      background: rgba(15,23,42,0.9);
      color: var(--text-muted);
      border: 1px solid rgba(148,163,184,0.5);
      box-shadow: none;
    }

    button.ghost {
      background: transparent;
      color: var(--text-muted);
      border: 1px dashed rgba(148,163,184,0.6);
      box-shadow: none;
    }

    button.small { padding: 0.25rem 0.7rem; font-size: 0.75rem; }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(249,115,22,0.4);
    }

    .hint { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.3rem; }
    .hidden { display: none; }

    /* Settings section */
    .settings-card-title { font-size: 0.9rem; font-weight: 700; margin-bottom: 0.35rem; }
    .settings-subtitle { font-size: 0.72rem; color: var(--text-muted); margin-bottom: 0.35rem; }

    .settings-section {
      margin-bottom: 0.75rem;
      border-radius: 0.75rem;
      padding: 0.6rem;
      background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,0.7));
      border: 1px solid rgba(31,41,55,0.8);
    }

    .settings-section-title { font-size: 0.8rem; font-weight: 600; margin-bottom: 0.35rem; }

    .settings-actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.35rem;
    }

    .settings-actions label {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    .settings-actions select {
      padding: 0.2rem 0.5rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.8);
      background: #020617;
      color: var(--text-main);
      font-size: 0.8rem;
    }

    .settings-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 0.35rem 0.75rem;
      align-items: center;
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }

    .settings-round-label { color: var(--text-muted); }
    .settings-round-label span { color: var(--text-main); font-weight: 500; }

    .settings-grid input[type="number"],
    .settings-grid input[type="text"] {
      width: 100%;
      max-width: 8rem;
      text-align: left;
      padding: 0.25rem 0.35rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      font-size: 0.75rem;
      touch-action: manipulation;
    }

    .settings-hint { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.35rem; }
    .settings-toggle-row { display: flex; justify-content: flex-end; margin: 0.5rem 0; }

    /* Score table */
    .table-wrapper {
      margin-top: 0.6rem;
      border-radius: 0.95rem;
      border: 1px solid rgba(148,163,184,0.2);
      overflow: hidden;
      background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,1));
    }

    .table-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 520px;
    }

    /* ✅ Sticky header (names stay visible while you scroll) */
    thead th {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(15,23,42,0.98);
      backdrop-filter: blur(18px);
    }

    th, td {
      padding: 0.35rem 0.4rem;
      text-align: center;
      border-bottom: 1px solid rgba(31,41,55,0.9);
      font-size: 0.78rem;
    }

    /* Sticky first column */
    th.round-header {
      text-align: left;
      width: 28%;
      position: sticky;
      left: 0;
      z-index: 12; /* above sticky header cells */
      background: rgba(17,24,39,0.96);
      border-right: 1px solid rgba(31,41,55,0.9);
    }

    th.round-header .round-title { font-weight: 600; font-size: 0.8rem; }
    th.round-header .round-desc { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.1rem; }

    .round-total { font-size: 0.7rem; margin-top: 0.15rem; color: var(--text-muted); }
    .round-total.ok { color: #4ade80; font-weight: 600; }
    .round-total.incomplete { color: #fbbf24; font-weight: 500; }

    th.player-header { min-width: 90px; }

    .player-header-inner {
      border-radius: 0.9rem;
      padding: 0.25rem 0.35rem 0.3rem;
      border: 1px solid rgba(148,163,184,0.5);
      position: relative;
      box-shadow: 0 8px 16px rgba(15,23,42,0.55);
    }

    .player-header-inner::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 2px solid transparent;
      background: linear-gradient(135deg, rgba(249,115,22,0.8), rgba(59,130,246,0.6)) border-box;
      mask:
        linear-gradient(#000 0 0) padding-box,
        linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      opacity: 0.25;
      pointer-events: none;
    }

    .player-name {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      font-weight: 600;
      line-height: 1.1;
      justify-content: center;
      flex-wrap: wrap;
    }

    /* ✅ Place badge */
    .player-place {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.08rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.55);
      background: rgba(15,23,42,0.75);
      color: var(--text-main);
      font-size: 0.65rem;
      font-weight: 700;
      letter-spacing: 0.03em;
    }

    .player-name-text { font-weight: 600; }

    .player-header-inner .player-total {
      font-size: 0.95rem;
      font-weight: 700;
      margin-top: 0.1rem;
      text-shadow: 0 1px 3px rgba(0,0,0,0.7);
    }

    .player-header-inner.winner {
      box-shadow: var(--winner-glow), 0 14px 30px rgba(16,185,129,0.55);
      border-color: rgba(45,212,191,0.8);
    }

    .player-header-inner.winner::before {
      background: linear-gradient(135deg, rgba(45,212,191,0.95), rgba(22,163,74,0.9)) border-box;
      opacity: 0.95;
    }

    .player-header-inner.winner .player-total { color: #bbf7d0; }

    .round-index {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.1rem;
      height: 1.1rem;
      border-radius: 999px;
      background: rgba(55,65,81,0.9);
      font-size: 0.6rem;
      margin-right: 0.35rem;
    }

    .cell-input {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.1rem;
    }

    .cell-input input[type="number"] {
      width: 4rem;
      text-align: center;
      border-radius: 0.6rem;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      padding: 0.25rem 0.3rem;
      font-size: 0.8rem;
      touch-action: manipulation;
    }

    .cell-input input[type="number"]:focus {
      outline: 2px solid rgba(249,115,22,0.75);
      outline-offset: 1px;
    }

    .cell-note { font-size: 0.68rem; color: var(--text-muted); min-height: 0.9rem; }
    .cell-note.highlight { color: #f97316; font-weight: 600; }

    tfoot td {
      border-top: 1px solid rgba(148,163,184,0.35);
      font-size: 0.75rem;
    }

    .footer-note {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 0.35rem;
      text-align: center;
    }

	.app-footer {
	  margin-top: 0.75rem;
	  padding: 0.6rem 0.2rem 0;
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  color: var(--text-muted);
	  font-size: 0.75rem;
	  border-top: 1px solid rgba(148,163,184,0.18);
	}
	

    @media (max-width: 640px) {
      header h1 { font-size: 1.25rem; }
      .card { padding: 0.7rem; }
      th, td { padding: 0.3rem 0.35rem; }
      .cell-input input[type="number"] { width: 3.4rem; }
      .settings-grid { grid-template-columns: 1.2fr auto; }
      .settings-actions { align-items: flex-start; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Canadian Salad Scorekeeper</h1>
      <p>Tap the bad cards / tricks per player &mdash; scores update automatically.</p>
    </header>

    <div class="settings-toggle-row">
      <button id="toggleSettingsBtn" type="button" class="ghost small">Show Settings</button>
    </div>

    <!-- SETTINGS SECTION -->
    <section class="card hidden" id="settingsCard">
      <div class="settings-card-title">Settings</div>
      <div class="settings-subtitle">
        Adjust players, names, decks, round limits, and which rules are used. These are saved on this device.
      </div>

      <!-- Players subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Players</div>
        <div class="controls">
          <div class="controls-group">
            <label for="playerCount">Number of players</label>
            <input type="number" id="playerCount" min="2" max="8" value="4" />
          </div>
          <div class="controls-group">
            <button id="buildBtn" type="button">Apply Players</button>
            <button id="resetBtn" type="button" class="secondary">Reset Scores</button>
          </div>
        </div>
        <p class="hint">
          Enter player names below. Low score wins.
        </p>
        <div id="playerNamesContainer" class="settings-grid" style="margin-top:0.35rem;">
          <!-- Player name inputs inserted here -->
        </div>
        <p class="hint" id="cardRemovalHint"></p>
      </div>

      <!-- Deck / Round limits subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Deck / Round Limits</div>
        <div class="controls" style="margin-bottom:0.5rem;">
          <div class="controls-group">
            <span style="font-size:0.78rem;color:var(--text-muted);">
              Limits auto-adjust based on player count (deal size + any removed cards). You can still fine-tune below.
            </span>
          </div>
          <div class="settings-actions">
            <label for="deckCount">
              Decks
              <select id="deckCount">
                <option value="1">1 deck</option>
                <option value="2">2 decks</option>
                <option value="3">3 decks</option>
                <option value="4">4 decks</option>
              </select>
            </label>
            <button id="restoreDefaultsBtn" type="button" class="ghost small">Restore Defaults</button>
          </div>
        </div>

        <div class="settings-grid" id="settingsGrid">
          <!-- Rows inserted dynamically -->
        </div>

        <div class="settings-hint" id="limitsHint">
          Auto defaults consider: player count, deal size, and the standard card-removal rules.
        </div>
      </div>

      <!-- Rules enabled / disabled subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Rules in this game</div>
        <div class="settings-grid" id="rulesGrid">
          <!-- Rule toggles inserted dynamically -->
        </div>
        <div class="settings-hint">
          Uncheck rules you want to skip for a shorter game. Disabled rules disappear from the main table and from the All-of-the-Above grid.
        </div>
      </div>
    </section>

    <!-- SCORE TABLE -->
    <section class="table-wrapper">
      <div class="table-scroll">
        <table id="scoreTable">
          <thead>
            <tr id="headerRow">
              <th class="round-header">
                <div class="round-title">Round</div>
                <div class="round-desc">Objective &amp; penalty per card/event</div>
              </th>
              <!-- Player headers injected here -->
            </tr>
          </thead>
          <tbody id="roundsBody"></tbody>
          <tfoot>
            <tr>
              <td colspan="99">
                “All of the Above” uses a per-rule breakdown for that one hand (see grid below). Low score wins.
              </td>
            </tr>
          </tfoot>
        </table>
      </div>
      <div class="footer-note">
        Works offline once opened. Add it to your Android home screen for quick access.
      </div>
    </section>

    <!-- All-of-the-Above details by rule -->
    <div class="settings-toggle-row">
      <button id="toggleAllDetailsBtn" type="button" class="ghost small">Show All-of-the-Above Grid</button>
    </div>
    <section class="card hidden" id="allDetailsCard">
      <div class="settings-card-title">All of the Above – Details by Rule</div>
      <div class="settings-subtitle">
        Enter, by rule, how many “bad” cards/events each player took in the All-of-the-Above hand.
        Each row shows “X / N cards” and totals roll up into Round 12 automatically.
      </div>
      <div class="table-scroll">
        <table>
          <thead>
            <tr id="allHeadRow">
              <th class="round-header">
                <div class="round-title">Rule</div>
                <div class="round-desc">Penalty per card/event</div>
              </th>
              <!-- Player headers injected here -->
            </tr>
          </thead>
          <tbody id="allRulesBody"></tbody>
        </table>
      </div>
    </section>
	<div class="app-footer">
	  <span>Cote Free Time Productions</span>
	  <span id="versionLabel"></span>
	</div>
  </div>

  <script>
    (function () {
      const STORAGE_KEY = "canadianSaladScores_v2.0";
	  const APP_VERSION = "v2.0";

      const rounds = [
        { name: "No RED Cards", description: "Each red card (♥ or ♦) = 5 pts", pointsPerCard: 5, defaultMaxCards: 26, maxCards: 26 },
        { name: "No EVEN Cards", description: "Each even-ranked card (2,4,6,8,10,Q) = 5 pts", pointsPerCard: 5, defaultMaxCards: 24, maxCards: 24 },
        { name: "No Tricks", description: "Each trick taken = 10 pts", pointsPerCard: 10, defaultMaxCards: 13, maxCards: 13 },
        { name: "No HEARTS", description: "Each ♥ = 10 pts", pointsPerCard: 10, defaultMaxCards: 13, maxCards: 13 },
        { name: "No FACE Cards", description: "Each J, Q, K = 10 pts", pointsPerCard: 10, defaultMaxCards: 12, maxCards: 12 },
        { name: "No SEVENS", description: "Each 7 = 30 pts", pointsPerCard: 30, defaultMaxCards: 4, maxCards: 4 },
        { name: "No ACES", description: "Each A = 30 pts", pointsPerCard: 30, defaultMaxCards: 4, maxCards: 4 },
        { name: "No QUEENS", description: "Each Q = 30 pts", pointsPerCard: 30, defaultMaxCards: 4, maxCards: 4 },
        { name: "No One-Eyed / KD", description: "Each J♠, J♥, or K♦ = 40 pts", pointsPerCard: 40, defaultMaxCards: 3, maxCards: 3 },
        { name: "No KING of SPADES", description: "If you took K♠, enter 1 = 75 pts", pointsPerCard: 75, defaultMaxCards: 1, maxCards: 1 },
        { name: "No LAST TRICK", description: "If you took last trick, enter 1 = 75 pts", pointsPerCard: 75, defaultMaxCards: 1, maxCards: 1 },
        { name: "All of the Above (per-rule)", description: "Totals from the All-of-the-Above details grid.", pointsPerCard: null, defaultMaxCards: null, maxCards: null }
      ];

      const playerColors = ["#f97316", "#22c55e", "#3b82f6", "#e11d48", "#a855f7", "#14b8a6", "#eab308", "#f97373"];

      // ✅ Simplified: all rules enabled by default (All-of-the-Above always shown)
      let includedRules = rounds.map(() => true);

      const headerRow = document.getElementById("headerRow");
      const roundsBody = document.getElementById("roundsBody");
      const playerCountInput = document.getElementById("playerCount");
      const buildBtn = document.getElementById("buildBtn");
      const resetBtn = document.getElementById("resetBtn");
      const scoreTable = document.getElementById("scoreTable");
      const settingsGrid = document.getElementById("settingsGrid");
      const restoreDefaultsBtn = document.getElementById("restoreDefaultsBtn");
      const deckCountSelect = document.getElementById("deckCount");
      const settingsCardEl = document.getElementById("settingsCard");
      const toggleSettingsBtn = document.getElementById("toggleSettingsBtn");
      const playerNamesContainer = document.getElementById("playerNamesContainer");
      const cardRemovalHint = document.getElementById("cardRemovalHint");
      const limitsHint = document.getElementById("limitsHint");

      const allDetailsCard = document.getElementById("allDetailsCard");
      const toggleAllDetailsBtn = document.getElementById("toggleAllDetailsBtn");
      const allHeadRow = document.getElementById("allHeadRow");
      const allRulesBody = document.getElementById("allRulesBody");
      const rulesGrid = document.getElementById("rulesGrid");
	  const versionLabel = document.getElementById("versionLabel");


      let playerCount = 4;
      let deckCount = 1;

      /* ---------------------- Player Count Presets & Limit Math ---------------------- */

      const EVEN_RANKS = new Set(["2","4","6","8","10","Q"]);
      const FACE_RANKS = new Set(["J","Q","K"]);

      function getPlayerPreset(pc) {
        // Returns recommended decks, cards per player, and removal rules (standard house rules you listed).
        if (pc === 3) return { recommendedDecks: 1, cardsPerPlayer: 13, removedSuitInstances: [{ suit: "C", instances: 1 }], removedSpecificCards: [] };
        if (pc === 4) return { recommendedDecks: 1, cardsPerPlayer: 13, removedSuitInstances: [], removedSpecificCards: [] };
        if (pc === 5) return { recommendedDecks: 1, cardsPerPlayer: 10, removedSuitInstances: [], removedSpecificCards: [{ rank: "2", suit: "C" }, { rank: "2", suit: "D" }] };
        if (pc === 6) return { recommendedDecks: 2, cardsPerPlayer: 13, removedSuitInstances: [{ suit: "C", instances: 1 }, { suit: "D", instances: 1 }], removedSpecificCards: [] };
        if (pc === 7) return { recommendedDecks: 2, cardsPerPlayer: 13, removedSuitInstances: [{ suit: "C", instances: 1 }], removedSpecificCards: [] };
        if (pc === 8) return { recommendedDecks: 2, cardsPerPlayer: 13, removedSuitInstances: [], removedSpecificCards: [] };
        // For 2 players or anything else, don't assume removals.
        return { recommendedDecks: deckCount, cardsPerPlayer: 13, removedSuitInstances: [], removedSpecificCards: [] };
      }

      function isRedSuit(suit) { return suit === "H" || suit === "D"; }

      function removedSuitCount(suit, removedSuitInstances) {
        return removedSuitInstances.reduce((sum, x) => sum + (x.suit === suit ? x.instances : 0), 0);
      }

      function countRemovedSpecific(filterFn, removedSpecificCards) {
        let c = 0;
        removedSpecificCards.forEach(card => { if (filterFn(card)) c += 1; });
        return c;
      }

      function computeMaxesForPreset(decks, preset) {
        // Start from full-deck counts for the chosen decks, then subtract removed suit instances + removed specific cards.
        const removedSuitInstances = preset.removedSuitInstances || [];
        const removedSpecificCards = preset.removedSpecificCards || [];

        // Suit removals remove 13 cards per instance
        const removedH = removedSuitCount("H", removedSuitInstances);
        const removedD = removedSuitCount("D", removedSuitInstances);
        const removedC = removedSuitCount("C", removedSuitInstances);
        const removedS = removedSuitCount("S", removedSuitInstances);

        // Helpers: how many even/face cards exist in a suit?
        const EVEN_PER_SUIT = 6; // 2,4,6,8,10,Q
        const FACE_PER_SUIT = 3; // J,Q,K

        // Specific removals:
        const removedSpecificRed = countRemovedSpecific(c => isRedSuit(c.suit), removedSpecificCards);
        const removedSpecificHearts = countRemovedSpecific(c => c.suit === "H", removedSpecificCards);
        const removedSpecificEven = countRemovedSpecific(c => EVEN_RANKS.has(c.rank), removedSpecificCards);
        const removedSpecificFace = countRemovedSpecific(c => FACE_RANKS.has(c.rank), removedSpecificCards);
        const removedSpecificSevens = countRemovedSpecific(c => c.rank === "7", removedSpecificCards);
        const removedSpecificAces = countRemovedSpecific(c => c.rank === "A", removedSpecificCards);
        const removedSpecificQueens = countRemovedSpecific(c => c.rank === "Q", removedSpecificCards);

        // One-eyed/KD specific cards: J♠, J♥, K♦
        const removedSpecificOneEyedKD = countRemovedSpecific(c =>
          (c.rank === "J" && (c.suit === "S" || c.suit === "H")) || (c.rank === "K" && c.suit === "D"),
          removedSpecificCards
        );

        // King of spades
        const removedSpecificKSpades = countRemovedSpecific(c => c.rank === "K" && c.suit === "S", removedSpecificCards);

        // Suit-removal impacts on categories:
        const removedSuitRed = (removedH + removedD) * 13;
        const removedSuitHearts = removedH * 13;
        const removedSuitEven = (removedH + removedD + removedC + removedS) * EVEN_PER_SUIT;
        const removedSuitFace = (removedH + removedD + removedC + removedS) * FACE_PER_SUIT;
        const removedSuitSevens = (removedH + removedD + removedC + removedS) * 1; // each suit has one 7
        const removedSuitAces = (removedH + removedD + removedC + removedS) * 1;
        const removedSuitQueens = (removedH + removedD + removedC + removedS) * 1;

        // One-eyed/KD impacts by suit removal:
        // J♠ removed if spades suit removed; J♥ removed if hearts suit removed; K♦ removed if diamonds suit removed.
        const removedSuitOneEyedKD = removedS * 1 + removedH * 1 + removedD * 1;

        // King of spades impacts by suit removal:
        const removedSuitKSpades = removedS * 1;

        const maxRed = Math.max(0, 26 * decks - removedSuitRed - removedSpecificRed);
        const maxEven = Math.max(0, 24 * decks - removedSuitEven - removedSpecificEven);
        const maxTricks = Math.max(0, preset.cardsPerPlayer || 13); // ✅ deal-size based (5 players => 10)
        const maxHearts = Math.max(0, 13 * decks - removedSuitHearts - removedSpecificHearts);
        const maxFace = Math.max(0, 12 * decks - removedSuitFace - removedSpecificFace);
        const maxSevens = Math.max(0, 4 * decks - removedSuitSevens - removedSpecificSevens);
        const maxAces = Math.max(0, 4 * decks - removedSuitAces - removedSpecificAces);
        const maxQueens = Math.max(0, 4 * decks - removedSuitQueens - removedSpecificQueens);
        const maxOneEyedKD = Math.max(0, 3 * decks - removedSuitOneEyedKD - removedSpecificOneEyedKD);
        const maxKingSpades = Math.max(0, 1 * decks - removedSuitKSpades - removedSpecificKSpades);
        const maxLastTrick = 1;

        return {
          red: maxRed,
          even: maxEven,
          tricks: maxTricks,
          hearts: maxHearts,
          face: maxFace,
          sevens: maxSevens,
          aces: maxAces,
          queens: maxQueens,
          oneEyedKD: maxOneEyedKD,
          kingSpades: maxKingSpades,
          lastTrick: maxLastTrick
        };
      }

      function applyPresetLimits({ forceDeckToRecommended = true } = {}) {
        const preset = getPlayerPreset(playerCount);

        // If playerCount has a known recommended deck count, auto-set deckCount (and UI) by default.
        if (forceDeckToRecommended && preset.recommendedDecks && preset.recommendedDecks >= 1) {
          deckCount = preset.recommendedDecks;
          deckCountSelect.value = String(deckCount);
        }

        // Only apply the “removed card/suit adjustments” when deckCount matches recommended.
        // If the user changes decks manually, we revert to scaled-by-decks defaults.
        const useAdjustments = (deckCount === preset.recommendedDecks);

        if (!useAdjustments) {
          // Simple scale: defaultMaxCards * deckCount (but keep tricks/last-trick deal-based sane)
          rounds.forEach((round, idx) => {
            if (round.defaultMaxCards != null) {
              round.maxCards = round.defaultMaxCards * deckCount;
            }
          });
          // Fix deal-based rounds when scaling:
          rounds[2].maxCards = preset.cardsPerPlayer || 13;  // No Tricks
          rounds[10].maxCards = 1;                           // No LAST TRICK
          if (limitsHint) {
            limitsHint.textContent = "Deck limits scaled by deck count (manual). Deal-size limits (tricks/last trick) still match the player deal.";
          }
          return;
        }

        const maxes = computeMaxesForPreset(deckCount, preset);

        rounds[0].maxCards = maxes.red;
        rounds[1].maxCards = maxes.even;
        rounds[2].maxCards = maxes.tricks;
        rounds[3].maxCards = maxes.hearts;
        rounds[4].maxCards = maxes.face;
        rounds[5].maxCards = maxes.sevens;
        rounds[6].maxCards = maxes.aces;
        rounds[7].maxCards = maxes.queens;
        rounds[8].maxCards = maxes.oneEyedKD;
        rounds[9].maxCards = maxes.kingSpades;
        rounds[10].maxCards = maxes.lastTrick;

        if (limitsHint) {
          limitsHint.textContent = "Auto defaults applied: adjusted for player count, deal size, and the standard removed-card rules for that player count.";
        }
      }

      /* ---------------------- Player Names Helpers ---------------------- */

      function getCurrentPlayerNamesFromSettings() {
        const inputs = playerNamesContainer.querySelectorAll("input[data-player-name]");
        const names = [];
        inputs.forEach((input, idx) => {
          const val = input.value.trim();
          names[idx] = val || `Player ${idx + 1}`;
        });
        return names;
      }

      function buildPlayerNameInputs(existingNames) {
        playerNamesContainer.innerHTML = "";
        const baseNames = existingNames || [];

        for (let p = 0; p < playerCount; p++) {
          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.textContent = `Player ${p + 1}`;

          const input = document.createElement("input");
          input.type = "text";
          input.dataset.playerName = String(p);
          input.placeholder = `Player ${p + 1}`;
          input.value = baseNames[p] || `Player ${p + 1}`;
          input.addEventListener("input", () => {
            syncHeaderNamesFromSettings();
            saveState();
          });

          playerNamesContainer.appendChild(labelDiv);
          playerNamesContainer.appendChild(input);
        }

        syncHeaderNamesFromSettings();
      }

      function syncHeaderNamesFromSettings() {
        const names = getCurrentPlayerNamesFromSettings();
        const headerNameNodes = document.querySelectorAll(".player-name-text");
        headerNameNodes.forEach((node, idx) => {
          if (names[idx]) node.textContent = names[idx];
        });

        const allHeaderCells = allHeadRow.querySelectorAll("th[data-all-player]");
        allHeaderCells.forEach((th, idx) => {
          if (names[idx]) th.textContent = names[idx];
        });
      }

      /* ---------------------- Card Removal Hint ---------------------- */

      function updateCardRemovalHint() {
        if (!cardRemovalHint) return;

        let msg = "";
        const pc = playerCount;
        const dc = deckCount;

        if (pc === 3) {
          msg = "3 players: use 1 deck. Remove all clubs (13 cards) before dealing. Each player gets 13 cards.";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 4) {
          msg = "4 players: use 1 deck. No cards removed (perfect deal: 13 cards each).";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 5) {
          msg = "5 players: use 1 deck. Remove the 2♣ and 2♦ (2 cards total), then deal 10 cards to each player.";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 6) {
          msg = "6 players: use 2 decks. Remove one full suit of clubs and one full suit of diamonds (26 cards total), then deal 13 cards to each player.";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else if (pc === 7) {
          msg = "7 players: use 2 decks. Remove one full suit of clubs (13 cards), then deal 13 cards to each player.";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else if (pc === 8) {
          msg = "8 players: use 2 decks. No cards removed (perfect deal: 13 cards each).";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else {
          msg = "No specific card-removal rule for this player count. Use any deck setup you like.";
        }

        cardRemovalHint.textContent = msg;
      }

      /* ---------------------- Rule Toggles UI ---------------------- */

      function buildRulesUI() {
        if (!rulesGrid) return;
        rulesGrid.innerHTML = "";

        for (let idx = 0; idx < rounds.length - 1; idx++) {
          const round = rounds[idx];

          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.innerHTML = `<span>${idx + 1}. ${round.name}</span>`;

          const wrapper = document.createElement("div");
          wrapper.style.display = "flex";
          wrapper.style.alignItems = "center";
          wrapper.style.justifyContent = "flex-end";
          wrapper.style.gap = "0.35rem";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.dataset.ruleToggle = String(idx);
          checkbox.checked = includedRules[idx];

          const span = document.createElement("span");
          span.style.fontSize = "0.75rem";
          span.style.color = "var(--text-muted)";
          span.textContent = "Use";

          checkbox.addEventListener("change", () => {
            includedRules[idx] = checkbox.checked;
            saveState();
            const saved = loadState();
            if (saved) {
              saved.includedRules = includedRules.slice();
              localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
              applyLoadedState(saved);
            } else {
              buildRoundsBody();
              buildAllHandGrid();
              updateAllHandTotals();
              updateScores();
            }
          });

          wrapper.appendChild(checkbox);
          wrapper.appendChild(span);

          rulesGrid.appendChild(labelDiv);
          rulesGrid.appendChild(wrapper);
        }
      }

      /* ---------------------- LocalStorage Helpers ---------------------- */

      function saveState() {
        const state = {
          playerCount,
          players: getCurrentPlayerNamesFromSettings(),
          scores: {},
          roundMaxCards: [],
          deckCount,
          allHand: {},
          includedRules: includedRules.slice()
        };

        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          const r = input.dataset.round;
          const p = input.dataset.player;
          const key = `${r}_${p}`;
          state.scores[key] = input.value || "";
        });

        rounds.forEach((round, idx) => {
          state.roundMaxCards[idx] = round.maxCards;
        });

        const allInputs = allRulesBody.querySelectorAll("input[data-all-rule]");
        allInputs.forEach((input) => {
          const rule = input.dataset.allRule;
          const player = input.dataset.player;
          if (!state.allHand[rule]) state.allHand[rule] = {};
          state.allHand[rule][player] = input.value || "";
        });

        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      function loadState() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        try { return JSON.parse(raw); } catch { return null; }
      }

      function applyLoadedState(state) {
        if (!state) return;

        if (state.deckCount != null) {
          const dc = parseInt(state.deckCount, 10);
          if (!isNaN(dc) && dc >= 1) deckCount = dc;
        }
        deckCountSelect.value = String(deckCount);

        if (Array.isArray(state.includedRules)) {
          includedRules = state.includedRules.slice();
        } else {
          includedRules = rounds.map(() => true);
        }

        playerCount = state.playerCount || 4;
        playerCountInput.value = playerCount;

        // ✅ apply auto preset limits first (so UI shows correct max cards)
        applyPresetLimits({ forceDeckToRecommended: false });

        // If saved roundMaxCards exists, it overrides.
        if (Array.isArray(state.roundMaxCards)) {
          state.roundMaxCards.forEach((val, idx) => {
            if (idx < rounds.length && val != null) {
              const v = parseInt(val, 10);
              if (!isNaN(v) && v >= 0) rounds[idx].maxCards = v;
            }
          });
        }

        buildPlayerHeaders();
        buildRoundsBody();
        buildSettingsUI();
        buildRulesUI();
        buildAllHandGrid();
        buildPlayerNameInputs(state.players || []);
        updateCardRemovalHint();

        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          const key = `${input.dataset.round}_${input.dataset.player}`;
          if (state.scores[key] !== undefined) input.value = state.scores[key];
        });

        const allHand = state.allHand || {};
        const allInputs = allRulesBody.querySelectorAll("input[data-all-rule]");
        allInputs.forEach((input) => {
          const r = input.dataset.allRule;
          const p = input.dataset.player;
          const val = allHand[r] && allHand[r][p];
          if (val !== undefined) input.value = val;
        });

        updateAllHandTotals();
        updateScores();
        updateSettingsInputsFromRounds();
      }

      /* ---------------------- Settings UI ---------------------- */

      function buildSettingsUI() {
        settingsGrid.innerHTML = "";

        rounds.forEach((round, idx) => {
          if (round.defaultMaxCards == null && round.maxCards == null) return;

          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.innerHTML = `<span>${idx + 1}. ${round.name}</span>`;

          const input = document.createElement("input");
          input.type = "number";
          input.min = "0";
          input.step = "1";
          input.dataset.roundSettings = String(idx);
          input.value = (round.maxCards != null) ? round.maxCards : 0;

          input.addEventListener("input", () => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            round.maxCards = val;
            input.value = String(val);
            enforceAllRoundLimits(idx);
            enforceAllHandLimitsForRule(idx);
            updateAllHandTotals();
            updateScores();
            saveState();
          });

          settingsGrid.appendChild(labelDiv);
          settingsGrid.appendChild(input);
        });
      }

      function updateSettingsInputsFromRounds() {
        const inputs = settingsGrid.querySelectorAll("input[type='number'][data-round-settings]");
        inputs.forEach((input) => {
          const idx = parseInt(input.dataset.roundSettings, 10);
          const round = rounds[idx];
          if (!round) return;
          if (round.maxCards != null) input.value = round.maxCards;
        });
      }

      /* ---------------------- UI Building ---------------------- */

      function clampPlayerCount(n) {
        if (isNaN(n)) return 4;
        return Math.min(Math.max(n, 2), 8);
      }

      function buildPlayerHeaders() {
        while (headerRow.children.length > 1) headerRow.removeChild(headerRow.lastElementChild);

        for (let p = 0; p < playerCount; p++) {
          const th = document.createElement("th");
          th.className = "player-header";
          th.dataset.player = String(p);

          const inner = document.createElement("div");
          inner.className = "player-header-inner";
          inner.style.background = `linear-gradient(135deg, ${hexToSoft(playerColors[p])}, ${playerColors[p]})`;

          const nameDiv = document.createElement("div");
          nameDiv.className = "player-name";

          const placeSpan = document.createElement("span");
          placeSpan.className = "player-place";
          placeSpan.textContent = ""; // filled in by ranking

          const nameSpan = document.createElement("span");
          nameSpan.className = "player-name-text";
          nameSpan.textContent = "Player " + (p + 1);

          nameDiv.appendChild(placeSpan);
          nameDiv.appendChild(nameSpan);

          const totalDiv = document.createElement("div");
          totalDiv.className = "player-total";
          totalDiv.textContent = "0";

          inner.appendChild(nameDiv);
          inner.appendChild(totalDiv);
          th.appendChild(inner);
          headerRow.appendChild(th);
        }

        syncHeaderNamesFromSettings();
      }

      function buildRoundsBody() {
        roundsBody.innerHTML = "";

        rounds.forEach((round, rIndex) => {
          if (rIndex < rounds.length - 1 && !includedRules[rIndex]) return;

          const tr = document.createElement("tr");

          const th = document.createElement("th");
          th.className = "round-header";

          const titleDiv = document.createElement("div");
          titleDiv.className = "round-title";

          const idxSpan = document.createElement("span");
          idxSpan.className = "round-index";
          idxSpan.textContent = String(rIndex + 1);

          const titleText = document.createElement("span");
          titleText.textContent = round.name;

          titleDiv.appendChild(idxSpan);
          titleDiv.appendChild(titleText);

          const descDiv = document.createElement("div");
          descDiv.className = "round-desc";
          descDiv.textContent = round.description;

          th.appendChild(titleDiv);
          th.appendChild(descDiv);

          const totalDiv = document.createElement("div");
          totalDiv.className = "round-total";
          totalDiv.dataset.round = String(rIndex);
          if (round.maxCards != null) {
            totalDiv.textContent = `0 / ${round.maxCards} cards`;
            totalDiv.classList.add("incomplete");
          } else {
            totalDiv.textContent = "";
          }
          th.appendChild(totalDiv);

          tr.appendChild(th);

          for (let p = 0; p < playerCount; p++) {
            const td = document.createElement("td");
            const wrapper = document.createElement("div");
            wrapper.className = "cell-input";

            const input = document.createElement("input");
            input.type = "number";
            input.min = "0";
            input.inputMode = "numeric";
            input.pattern = "[0-9]*";
            input.dataset.round = String(rIndex);
            input.dataset.player = String(p);

            const note = document.createElement("div");
            note.className = "cell-note";
            note.textContent = "0 pts";

            if (rIndex === rounds.length - 1) {
              input.readOnly = true;
              input.addEventListener("focus", (e) => e.target.blur());
              wrapper.appendChild(input);
              wrapper.appendChild(note);
            } else {
              input.addEventListener("input", () => {
                enforceRoundLimitForInput(input);
                updateScores();
                saveState();
              });
              wrapper.appendChild(input);
              wrapper.appendChild(note);
            }

            td.appendChild(wrapper);
            tr.appendChild(td);
          }

          roundsBody.appendChild(tr);
        });
      }

      function buildAllHandGrid() {
        while (allHeadRow.children.length > 1) allHeadRow.removeChild(allHeadRow.lastElementChild);

        const names = getCurrentPlayerNamesFromSettings();
        for (let p = 0; p < playerCount; p++) {
          const th = document.createElement("th");
          th.dataset.allPlayer = String(p);
          th.textContent = names[p] || `P${p + 1}`;
          allHeadRow.appendChild(th);
        }

        allRulesBody.innerHTML = "";
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;

          const round = rounds[rIndex];
          const tr = document.createElement("tr");

          const th = document.createElement("th");
          th.className = "round-header";
          th.innerHTML =
            `<div class="round-title">${rIndex + 1}. ${round.name}</div>` +
            `<div class="round-desc">×${round.pointsPerCard} pts</div>` +
            `<div class="round-total all-round-total" data-all-round="${rIndex}"></div>`;
          tr.appendChild(th);

          for (let p = 0; p < playerCount; p++) {
            const td = document.createElement("td");
            const wrapper = document.createElement("div");
            wrapper.className = "cell-input";

            const input = document.createElement("input");
            input.type = "number";
            input.min = "0";
            input.step = "1";
            input.inputMode = "numeric";
            input.pattern = "[0-9]*";
            input.dataset.allRule = String(rIndex);
            input.dataset.player = String(p);
            input.addEventListener("input", () => {
              enforceAllHandLimitForInput(input);
              updateAllHandTotals();
              saveState();
            });

            const note = document.createElement("div");
            note.className = "cell-note";
            note.textContent = "0 pts";

            wrapper.appendChild(input);
            wrapper.appendChild(note);
            td.appendChild(wrapper);
            tr.appendChild(td);
          }

          allRulesBody.appendChild(tr);
        }

        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;
          const round = rounds[rIndex];
          const indicator = document.querySelector(`.all-round-total[data-all-round="${rIndex}"]`);
          if (!indicator || round.maxCards == null) continue;
          indicator.classList.remove("ok", "incomplete");
          indicator.textContent = `0 / ${round.maxCards} cards`;
          indicator.classList.add("incomplete");
        }
      }

      /* ---------------------- Card-limit Enforcement ---------------------- */

      function enforceRoundLimitForInput(input) {
        const rIndex = parseInt(input.dataset.round, 10);
        const round = rounds[rIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRound = roundsBody.querySelectorAll(`input[data-round="${rIndex}"]`);

        let sumOthers = 0;
        inputsThisRound.forEach((el) => {
          if (el === input) return;
          const v = parseInt(el.value || "0", 10);
          if (!isNaN(v) && v > 0) sumOthers += v;
        });

        let val = parseInt(input.value || "0", 10);
        if (isNaN(val) || val < 0) val = 0;

        const allowedForThis = Math.max(0, max - sumOthers);
        if (val > allowedForThis) {
          val = allowedForThis;
          input.value = val ? String(val) : "";
        }
      }

      function enforceAllRoundLimits(onlyRoundIndex = null) {
        const roundsToCheck = onlyRoundIndex == null ? rounds.map((_, idx) => idx) : [onlyRoundIndex];

        roundsToCheck.forEach((rIndex) => {
          const round = rounds[rIndex];
          if (!round || round.maxCards == null) return;

          const max = round.maxCards;
          const inputsThisRound = roundsBody.querySelectorAll(`input[data-round="${rIndex}"]`);

          let total = 0;
          inputsThisRound.forEach((input) => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            total += val;
          });

          if (total <= max) return;

          let remaining = max;
          inputsThisRound.forEach((input) => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            if (val > remaining) val = remaining;
            input.value = val ? String(val) : "";
            remaining -= val;
          });
        });
      }

      function enforceAllHandLimitForInput(input) {
        const rIndex = parseInt(input.dataset.allRule, 10);
        const round = rounds[rIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRule = allRulesBody.querySelectorAll(`input[data-all-rule="${rIndex}"]`);

        let sumOthers = 0;
        inputsThisRule.forEach((el) => {
          if (el === input) return;
          const v = parseInt(el.value || "0", 10);
          if (!isNaN(v) && v > 0) sumOthers += v;
        });

        let val = parseInt(input.value || "0", 10);
        if (isNaN(val) || val < 0) val = 0;

        const allowedForThis = Math.max(0, max - sumOthers);
        if (val > allowedForThis) {
          val = allowedForThis;
          input.value = val ? String(val) : "";
        }
      }

      function enforceAllHandLimitsForRule(ruleIndex) {
        const round = rounds[ruleIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRule = allRulesBody.querySelectorAll(`input[data-all-rule="${ruleIndex}"]`);

        let total = 0;
        inputsThisRule.forEach((input) => {
          let val = parseInt(input.value || "0", 10);
          if (isNaN(val) || val < 0) val = 0;
          total += val;
        });

        if (total <= max) return;

        let remaining = max;
        inputsThisRule.forEach((input) => {
          let val = parseInt(input.value || "0", 10);
          if (isNaN(val) || val < 0) val = 0;
          if (val > remaining) val = remaining;
          input.value = val ? String(val) : "";
          remaining -= val;
        });
      }

      function enforceAllHandLimitsForAll() {
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          enforceAllHandLimitsForRule(rIndex);
        }
      }

      /* ---------------------- Score Logic + Places ---------------------- */

      function resetScores() {
        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => { input.value = ""; });

        const notes = scoreTable.querySelectorAll(".cell-note");
        notes.forEach((n) => { n.textContent = "0 pts"; n.classList.remove("highlight"); });

        const allInputs = allRulesBody.querySelectorAll("input[data-all-rule]");
        allInputs.forEach((input) => { input.value = ""; });

        const allNotes = allRulesBody.querySelectorAll(".cell-note");
        allNotes.forEach((n) => { n.textContent = "0 pts"; n.classList.remove("highlight"); });

        updateAllHandTotals();

        const totals = scoreTable.querySelectorAll(".player-total");
        totals.forEach((t) => (t.textContent = "0"));

        const headers = scoreTable.querySelectorAll(".player-header-inner");
        headers.forEach((h) => h.classList.remove("winner"));

        const placeBadges = scoreTable.querySelectorAll(".player-place");
        placeBadges.forEach((b) => (b.textContent = ""));

        const totalEls = document.querySelectorAll(".round-total[data-round]");
        totalEls.forEach((el) => {
          const rIndex = parseInt(el.dataset.round || "-1", 10);
          const round = rounds[rIndex];
          el.classList.remove("ok", "incomplete");
          if (round && round.maxCards != null) {
            el.textContent = `0 / ${round.maxCards} cards`;
            el.classList.add("incomplete");
          } else {
            el.textContent = "";
          }
        });

        localStorage.removeItem(STORAGE_KEY);
      }

      function updatePlaces(totals) {
        const badges = document.querySelectorAll(".player-place");
        if (!badges || badges.length === 0) return;

        const anyNonZero = totals.some(v => v !== 0);
        if (!anyNonZero) {
          badges.forEach(b => b.textContent = "");
          return;
        }

        const items = totals.map((t, idx) => ({ idx, total: t }));
        items.sort((a, b) => a.total - b.total || a.idx - b.idx);

        let lastTotal = null;
        let rank = 0;
        let seen = 0;

        const rankByIdx = new Array(totals.length).fill(0);
        const tieByIdx = new Array(totals.length).fill(false);

        while (seen < items.length) {
          const cur = items[seen];
          if (lastTotal === null || cur.total !== lastTotal) {
            rank = seen + 1;
            lastTotal = cur.total;
          } else {
            tieByIdx[cur.idx] = true;
          }
          rankByIdx[cur.idx] = rank;
          seen++;
        }

        // Mark ties for all players sharing same total
        const totalToPlayers = new Map();
        totals.forEach((t, idx) => {
          if (!totalToPlayers.has(t)) totalToPlayers.set(t, []);
          totalToPlayers.get(t).push(idx);
        });
        totalToPlayers.forEach((arr) => {
          if (arr.length > 1) arr.forEach(i => tieByIdx[i] = true);
        });

        badges.forEach((b, idx) => {
          const r = rankByIdx[idx] || (idx + 1);
          b.textContent = (tieByIdx[idx] ? "T#" : "#") + r;
        });
      }

      function updateScores() {
        const totals = new Array(playerCount).fill(0);
        const roundSums = new Array(rounds.length).fill(0);

        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          const r = parseInt(input.dataset.round, 10);
          const p = parseInt(input.dataset.player, 10);
          const round = rounds[r];
          const count = parseInt(input.value || "0", 10) || 0;

          if (!isNaN(count) && count > 0 && round.maxCards != null) roundSums[r] += count;

          let points = 0;
          if (round.pointsPerCard === null) points = count; // Round 12 already points
          else points = count * round.pointsPerCard;

          totals[p] += points;

          const note = input.parentElement.querySelector(".cell-note");
          if (note) {
            note.textContent = points + " pts";
            note.classList.toggle("highlight", points > 0);
          }
        });

        updateRoundTotals(roundSums);

        const totalNodes = document.querySelectorAll(".player-total");
        const headers = document.querySelectorAll(".player-header-inner");
        totalNodes.forEach((node, idx) => { node.textContent = totals[idx]; });

        headers.forEach((h) => h.classList.remove("winner"));

        const anyNonZero = totals.some((v) => v !== 0);
        if (anyNonZero) {
          const minTotal = Math.min(...totals);
          totals.forEach((t, idx) => { if (t === minTotal) headers[idx].classList.add("winner"); });
        }

        // ✅ update place badges
        updatePlaces(totals);
      }

      function updateRoundTotals(roundSums) {
        roundSums.forEach((sum, rIndex) => {
          const round = rounds[rIndex];
          const el = document.querySelector(`.round-total[data-round="${rIndex}"]`);
          if (!el || !round) return;

          el.classList.remove("ok", "incomplete");
          if (round.maxCards == null) { el.textContent = ""; return; }

          el.textContent = `${sum} / ${round.maxCards} cards`;
          if (sum === round.maxCards) el.classList.add("ok");
          else el.classList.add("incomplete");
        });
      }

      function updateAllHandTotals() {
        const totalsByPlayer = new Array(playerCount).fill(0);
        const ruleTotals = new Array(rounds.length - 1).fill(0);

        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;

          const rule = rounds[rIndex];
          const inputsThisRule = allRulesBody.querySelectorAll(`input[data-all-rule="${rIndex}"]`);

          inputsThisRule.forEach((input) => {
            const p = parseInt(input.dataset.player, 10);
            const cnt = parseInt(input.value || "0", 10) || 0;
            const pts = cnt * (rule.pointsPerCard || 0);
            totalsByPlayer[p] += pts;
            ruleTotals[rIndex] += cnt;

            const note = input.parentElement.querySelector(".cell-note");
            if (note) {
              note.textContent = pts + " pts";
              note.classList.toggle("highlight", pts > 0);
            }
          });
        }

        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;
          const round = rounds[rIndex];
          const indicator = document.querySelector(`.all-round-total[data-all-round="${rIndex}"]`);
          if (!indicator || round.maxCards == null) continue;
          indicator.classList.remove("ok", "incomplete");
          indicator.textContent = `${ruleTotals[rIndex]} / ${round.maxCards} cards`;
          if (ruleTotals[rIndex] === round.maxCards) indicator.classList.add("ok");
          else indicator.classList.add("incomplete");
        }

        const allRowIndex = rounds.length - 1;
        for (let p = 0; p < playerCount; p++) {
          const mainInput = document.querySelector(`input[data-round="${allRowIndex}"][data-player="${p}"]`);
          if (mainInput) {
            const total = totalsByPlayer[p];
            mainInput.value = total ? String(total) : "";
          }
        }

        updateScores();
      }

      /* ---------------------- Utility ---------------------- */

      function hexToSoft(hex) {
        const base = "#1d4ed8";
        try {
          const c1 = hexToRgb(hex);
          const c2 = hexToRgb(base);
          const mix = {
            r: Math.round((c1.r + c2.r * 1.4) / 2.4),
            g: Math.round((c1.g + c2.g * 1.4) / 2.4),
            b: Math.round((c1.b + c2.b * 1.4) / 2.4)
          };
          return `rgba(${mix.r},${mix.g},${mix.b},0.6)`;
        } catch { return "rgba(30,64,175,0.55)"; }
      }

      function hexToRgb(hex) {
        const c = hex.replace("#", "");
        if (c.length !== 6) return null;
        const v = parseInt(c, 16);
        return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
      }

      /* ---------------------- Restore Defaults ---------------------- */

      function restoreDefaults() {
        // ✅ Re-apply the computed preset max limits (and rebuild indicators)
        applyPresetLimits({ forceDeckToRecommended: true });
        updateSettingsInputsFromRounds();
        buildRoundsBody();
        buildAllHandGrid();
        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        updateScores();
        saveState();
      }

      /* ---------------------- Event Setup ---------------------- */

      buildBtn.addEventListener("click", () => {
        const desired = clampPlayerCount(parseInt(playerCountInput.value, 10));
        const existingNames = getCurrentPlayerNamesFromSettings();
        playerCount = desired;
        playerCountInput.value = desired;

        // ✅ Apply player preset (includes deck recommendation + adjusted limits)
        applyPresetLimits({ forceDeckToRecommended: true });

        buildPlayerHeaders();
        buildRoundsBody();
        buildSettingsUI();
        buildRulesUI();
        buildAllHandGrid();
        buildPlayerNameInputs(existingNames);
        updateCardRemovalHint();

        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        saveState();
      });

      resetBtn.addEventListener("click", resetScores);

      restoreDefaultsBtn.addEventListener("click", restoreDefaults);

      deckCountSelect.addEventListener("change", () => {
        const dc = parseInt(deckCountSelect.value, 10);
        deckCount = (!isNaN(dc) && dc >= 1) ? dc : 1;

        // ✅ Re-apply limits (if deck != recommended, it scales + keeps tricks deal-based)
        applyPresetLimits({ forceDeckToRecommended: false });

        updateSettingsInputsFromRounds();
        buildRoundsBody();
        buildAllHandGrid();
        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        updateScores();
        updateCardRemovalHint();
        saveState();
      });

      toggleSettingsBtn.addEventListener("click", () => {
        const nowHidden = settingsCardEl.classList.toggle("hidden");
        toggleSettingsBtn.textContent = nowHidden ? "Show Settings" : "Hide Settings";
      });

      toggleAllDetailsBtn.addEventListener("click", () => {
        const nowHidden = allDetailsCard.classList.toggle("hidden");
        toggleAllDetailsBtn.textContent = nowHidden ? "Show All-of-the-Above Grid" : "Hide All-of-the-Above Grid";
      });

      /* ---------------------- Initial Load ---------------------- */

      // default structure
      buildPlayerHeaders();
      buildRoundsBody();
      buildSettingsUI();
      buildRulesUI();
      buildAllHandGrid();
      buildPlayerNameInputs();
      updateCardRemovalHint();

      // apply saved state if present
      const saved = loadState();
      if (saved) applyLoadedState(saved);
      else {
        // ✅ default preset for 4 players
        applyPresetLimits({ forceDeckToRecommended: true });
        updateSettingsInputsFromRounds();
        buildRoundsBody();
        buildAllHandGrid();
        updateAllHandTotals();
        updateScores();
      }
	  
	  if (versionLabel) {
		versionLabel.textContent = APP_VERSION;
	  }


    })();
  </script>
</body>
</html>