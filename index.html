<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Canadian Salad Scorekeeper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <style>
    :root {
      --bg: #050816;
      --bg-soft: #0c1224;
      --card: #111827;
      --card-soft: #1f2937;
      --accent: #f97316;
      --accent-soft: rgba(249, 115, 22, 0.14);
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --border-subtle: #1f2933;
      --winner-glow: 0 0 0 2px rgba(52, 211, 153, 0.7);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 50%, #000 100%);
      color: var(--text-main);
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 1rem 0.75rem 2.5rem;
      padding-top: calc(1rem + env(safe-area-inset-top));
      padding-bottom: calc(2.5rem + env(safe-area-inset-bottom));
    }

    header { text-align: center; margin-bottom: 0.5rem; }
    header h1 { margin: 0; font-size: 1.5rem; letter-spacing: 0.05em; }
    header p { margin: 0.35rem 0 0; font-size: 0.8rem; color: var(--text-muted); }

    .card {
      background: linear-gradient(135deg, rgba(15,23,42,0.96), rgba(17,24,39,0.96));
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,0.15);
      box-shadow: 0 18px 40px rgba(15,23,42,0.65);
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      backdrop-filter: blur(14px);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: space-between;
    }

    .controls-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    .controls label { font-size: 0.8rem; color: var(--text-muted); }

    .controls input[type="number"] {
      width: 4rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.6rem;
      border: 1px solid var(--border-subtle);
      background: #020617;
      color: var(--text-main);
      font-size: 0.9rem;
      text-align: center;
      touch-action: manipulation;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      background: radial-gradient(circle at top left, #fb923c, #f97316);
      color: #111827;
      box-shadow: 0 10px 25px rgba(249,115,22,0.4);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      cursor: pointer;
    }

    button.secondary {
      background: rgba(15,23,42,0.9);
      color: var(--text-muted);
      border: 1px solid rgba(148,163,184,0.5);
      box-shadow: none;
    }

    button.ghost {
      background: transparent;
      color: var(--text-muted);
      border: 1px dashed rgba(148,163,184,0.6);
      box-shadow: none;
    }

    button.small { padding: 0.25rem 0.7rem; font-size: 0.75rem; }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(249,115,22,0.4);
    }

    .hint { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.3rem; }
    .hidden { display: none; }

    /* Settings section */
    .settings-card-title { font-size: 0.9rem; font-weight: 700; margin-bottom: 0.35rem; }
    .settings-subtitle { font-size: 0.72rem; color: var(--text-muted); margin-bottom: 0.35rem; }

    .settings-section {
      margin-bottom: 0.75rem;
      border-radius: 0.75rem;
      padding: 0.6rem;
      background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,0.7));
      border: 1px solid rgba(31,41,55,0.8);
    }

    .settings-section-title { font-size: 0.8rem; font-weight: 600; margin-bottom: 0.35rem; }

    .settings-actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.35rem;
    }

    .settings-actions label {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    .settings-actions select {
      padding: 0.2rem 0.5rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.8);
      background: #020617;
      color: var(--text-main);
      font-size: 0.8rem;
    }

    .settings-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 0.35rem 0.75rem;
      align-items: center;
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }

    .settings-round-label { color: var(--text-muted); }
    .settings-round-label span { color: var(--text-main); font-weight: 500; }

    .settings-grid input[type="number"],
    .settings-grid input[type="text"] {
      width: 100%;
      max-width: 8rem;
      text-align: left;
      padding: 0.25rem 0.35rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      font-size: 0.75rem;
      touch-action: manipulation;
    }

    .settings-hint { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.35rem; }
    .settings-toggle-row { display: flex; justify-content: flex-end; margin: 0.5rem 0; }

    /* ============================
       Table containers
       ============================ */

	.table-wrapper {
	  margin-top: 0.6rem;
	  border-radius: 0.95rem;
	  border: 1px solid rgba(148,163,184,0.2);
	  overflow: visible; /* ✅ critical: allows sticky to work */
	  background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,1));
	}

    .table-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 520px;
    }

    th, td {
      padding: 0.35rem 0.4rem;
      text-align: center;
      border-bottom: 1px solid rgba(31,41,55,0.9);
      font-size: 0.78rem;
    }

    /* Sticky first column */
    th.round-header {
      text-align: left;
      width: 28%;
      position: sticky;
      left: 0;
      z-index: 8;
      background: rgba(17,24,39,0.96);
      border-right: 1px solid rgba(31,41,55,0.9);
    }

    th.round-header .round-title { font-weight: 600; font-size: 0.8rem; }
    th.round-header .round-desc { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.1rem; }

    .round-total { font-size: 0.7rem; margin-top: 0.15rem; color: var(--text-muted); }
    .round-total.ok { color: #4ade80; font-weight: 600; }
    .round-total.incomplete { color: #fbbf24; font-weight: 500; }

    th.player-header { min-width: 90px; }

    .player-header-inner {
      border-radius: 0.9rem;
      padding: 0.25rem 0.35rem 0.3rem;
      border: 1px solid rgba(148,163,184,0.5);
      position: relative;
      box-shadow: 0 8px 16px rgba(15,23,42,0.55);
    }

    .player-header-inner::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 2px solid transparent;
      background: linear-gradient(135deg, rgba(249,115,22,0.8), rgba(59,130,246,0.6)) border-box;
      mask:
        linear-gradient(#000 0 0) padding-box,
        linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      opacity: 0.25;
      pointer-events: none;
    }

    .player-name {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      font-weight: 600;
      line-height: 1.1;
      justify-content: center;
      flex-wrap: wrap;
    }

    .player-place {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.08rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.55);
      background: rgba(15,23,42,0.75);
      color: var(--text-main);
      font-size: 0.65rem;
      font-weight: 700;
      letter-spacing: 0.03em;
    }

    .player-name-text { font-weight: 600; }

    .player-header-inner .player-total {
      font-size: 0.95rem;
      font-weight: 700;
      margin-top: 0.1rem;
      text-shadow: 0 1px 3px rgba(0,0,0,0.7);
    }

    .player-header-inner.winner {
      box-shadow: var(--winner-glow), 0 14px 30px rgba(16,185,129,0.55);
      border-color: rgba(45,212,191,0.8);
    }

    .player-header-inner.winner::before {
      background: linear-gradient(135deg, rgba(45,212,191,0.95), rgba(22,163,74,0.9)) border-box;
      opacity: 0.95;
    }

    .player-header-inner.winner .player-total { color: #bbf7d0; }

    .round-index {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.1rem;
      height: 1.1rem;
      border-radius: 999px;
      background: rgba(55,65,81,0.9);
      font-size: 0.6rem;
      margin-right: 0.35rem;
    }

    .cell-input {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.1rem;
    }

    .cell-input input[type="number"] {
      width: 4rem;
      text-align: center;
      border-radius: 0.6rem;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      padding: 0.25rem 0.3rem;
      font-size: 0.8rem;
      touch-action: manipulation;
    }

    .cell-input input[type="number"]:focus {
      outline: 2px solid rgba(249,115,22,0.75);
      outline-offset: 1px;
    }

    .cell-note { font-size: 0.68rem; color: var(--text-muted); min-height: 0.9rem; }
    .cell-note.highlight { color: #f97316; font-weight: 600; }

    tfoot td {
      border-top: 1px solid rgba(148,163,184,0.35);
      font-size: 0.75rem;
    }

    .footer-note {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 0.35rem;
      text-align: center;
    }

    /* ============================
       Robust sticky header clone
       ============================ */

    .table-header-sticky {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(15,23,42,0.98);
      backdrop-filter: blur(18px);
      border-bottom: 1px solid rgba(148,163,184,0.18);
    }

    .table-header-scroll {
      overflow: hidden; /* header scroll is synced via JS */
    }
	
	/* ✅ keep rounded corners on the sticky header block */
	#tableHeaderSticky {
	  border-top-left-radius: 0.95rem;
	  border-top-right-radius: 0.95rem;
	  overflow: hidden;
	}

	/* ✅ keep rounded corners on the scrollable body area */
	#tableBodyScroll {
	  border-bottom-left-radius: 0.95rem;
	  border-bottom-right-radius: 0.95rem;
	  overflow-x: auto;
	  -webkit-overflow-scrolling: touch;
	}


    #scoreHeaderTable,
    #allHeaderTable {
      width: 100%;
      border-collapse: collapse;
      min-width: 520px;
    }

    /* hide the original theads inside body scrollers (we render sticky clone instead) */
    #scoreTable thead,
    #allTable thead {
      display: none;
    }

    /* ============================
       Footer line
       ============================ */
    .app-footer {
      margin-top: 0.75rem;
      padding: 0.6rem 0.2rem 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--text-muted);
      font-size: 0.75rem;
      border-top: 1px solid rgba(148,163,184,0.18);
    }

    @media (max-width: 640px) {
      header h1 { font-size: 1.25rem; }
      .card { padding: 0.7rem; }
      th, td { padding: 0.3rem 0.35rem; }
      .cell-input input[type="number"] { width: 3.4rem; }
      .settings-grid { grid-template-columns: 1.2fr auto; }
      .settings-actions { align-items: flex-start; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Canadian Salad Scorekeeper</h1>
      <p>Tap the bad cards / tricks per player &mdash; scores update automatically.</p>
    </header>

    <div class="settings-toggle-row">
      <button id="toggleSettingsBtn" type="button" class="ghost small">Show Settings</button>
    </div>

    <!-- SETTINGS SECTION -->
    <section class="card hidden" id="settingsCard">
      <div class="settings-card-title">Settings</div>
      <div class="settings-subtitle">
        Adjust players, names, decks, round limits, and which rules are used. These are saved on this device.
      </div>

      <!-- Players subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Players</div>
        <div class="controls">
          <div class="controls-group">
            <label for="playerCount">Number of players</label>
            <input type="number" id="playerCount" min="2" max="8" value="4" />
          </div>
          <div class="controls-group">
            <button id="buildBtn" type="button">Apply Players</button>
            <button id="resetBtn" type="button" class="secondary">Reset Scores</button>
          </div>
        </div>
        <p class="hint">Enter player names below. Low score wins.</p>
        <div id="playerNamesContainer" class="settings-grid" style="margin-top:0.35rem;"></div>
        <p class="hint" id="cardRemovalHint"></p>
      </div>

      <!-- Deck / Round limits subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Deck / Round Limits</div>
        <div class="controls" style="margin-bottom:0.5rem;">
          <div class="controls-group">
            <span style="font-size:0.78rem;color:var(--text-muted);">
              Defaults assume a 52-card deck. Card limits scale with number of decks.
            </span>
          </div>
          <div class="settings-actions">
            <label for="deckCount">
              Decks
              <select id="deckCount">
                <option value="1">1 deck</option>
                <option value="2">2 decks</option>
                <option value="3">3 decks</option>
                <option value="4">4 decks</option>
              </select>
            </label>
            <button id="restoreDefaultsBtn" type="button" class="ghost small">Restore Defaults</button>
          </div>
        </div>

        <div class="settings-grid" id="settingsGrid"></div>

        <div class="settings-hint">
          Defaults are “per deck” × number of decks. Changing decks recalculates limits; then you can fine-tune per round.
        </div>
      </div>

      <!-- Rules enabled / disabled subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Rules in this game</div>
        <div class="settings-grid" id="rulesGrid"></div>
        <div class="settings-hint">
          Uncheck rules you want to skip for a shorter game. Disabled rules disappear from the main table and from the All-of-the-Above grid.
        </div>
      </div>
    </section>

    <!-- SCORE TABLE -->
    <section class="table-wrapper">
      <!-- ✅ Sticky header that stays visible during vertical scroll -->
      <div class="table-header-sticky" id="tableHeaderSticky">
        <div class="table-header-scroll" id="tableHeaderScroll">
          <table id="scoreHeaderTable" aria-hidden="true">
            <thead>
              <tr id="headerRowSticky">
                <th class="round-header">
                  <div class="round-title">Round</div>
                  <div class="round-desc">Objective &amp; penalty per card/event</div>
                </th>
              </tr>
            </thead>
          </table>
        </div>
      </div>

      <!-- Body (horizontally scrollable) -->
      <div class="table-scroll" id="tableBodyScroll">
        <table id="scoreTable">
          <thead>
            <tr id="headerRow">
              <th class="round-header">
                <div class="round-title">Round</div>
                <div class="round-desc">Objective &amp; penalty per card/event</div>
              </th>
            </tr>
          </thead>
          <tbody id="roundsBody"></tbody>
          <tfoot>
            <tr>
              <td colspan="99">
                “All of the Above” uses a per-rule breakdown for that one hand (see grid below). Low score wins.
              </td>
            </tr>
          </tfoot>
        </table>
      </div>

      <div class="footer-note">
        Works offline once opened. Add it to your Android home screen for quick access.
      </div>
    </section>

    <!-- All-of-the-Above details by rule -->
    <div class="settings-toggle-row">
      <button id="toggleAllDetailsBtn" type="button" class="ghost small">Show All-of-the-Above Grid</button>
    </div>

    <section class="card hidden" id="allDetailsCard">
      <div class="settings-card-title">All of the Above – Details by Rule</div>
      <div class="settings-subtitle">
        Enter, by rule, how many “bad” cards/events each player took in the All-of-the-Above hand.
        Each row shows “X / N cards” and totals roll up into Round 12 automatically.
      </div>

      <!-- ✅ Sticky header for All-of-the-Above -->
      <div class="table-header-sticky" id="allHeaderSticky">
        <div class="table-header-scroll" id="allHeaderScroll">
          <table id="allHeaderTable" aria-hidden="true">
            <thead>
              <tr id="allHeadRowSticky">
                <th class="round-header">
                  <div class="round-title">Rule</div>
                  <div class="round-desc">Penalty per card/event</div>
                </th>
              </tr>
            </thead>
          </table>
        </div>
      </div>

      <!-- Body (horizontally scrollable) -->
      <div class="table-scroll" id="allBodyScroll">
        <table id="allTable">
          <thead>
            <tr id="allHeadRow">
              <th class="round-header">
                <div class="round-title">Rule</div>
                <div class="round-desc">Penalty per card/event</div>
              </th>
            </tr>
          </thead>
          <tbody id="allRulesBody"></tbody>
        </table>
      </div>
    </section>

    <!-- Footer line -->
    <div class="app-footer">
      <span>Cote Free Time Productions</span>
      <span id="versionLabel"></span>
    </div>
  </div>

  <script>
    (function () {
      const STORAGE_KEY = "canadianSaladScores_v11";
      const APP_VERSION = "v11";

      // Rounds: defaultMaxCards is per-deck; maxCards is current total after deck scaling.
      const rounds = [
        { name: "No RED Cards", description: "Each red card (♥ or ♦) = 5 pts", pointsPerCard: 5, defaultMaxCards: 26, maxCards: 26 },
        { name: "No EVEN Cards", description: "Each even-ranked card (2,4,6,8,10,Q) = 5 pts", pointsPerCard: 5, defaultMaxCards: 24, maxCards: 24 },
        { name: "No Tricks", description: "Each trick taken = 10 pts", pointsPerCard: 10, defaultMaxCards: 13, maxCards: 13 },
        { name: "No HEARTS", description: "Each ♥ = 10 pts", pointsPerCard: 10, defaultMaxCards: 13, maxCards: 13 },
        { name: "No FACE Cards", description: "Each J, Q, K = 10 pts", pointsPerCard: 10, defaultMaxCards: 12, maxCards: 12 },
        { name: "No SEVENS", description: "Each 7 = 30 pts", pointsPerCard: 30, defaultMaxCards: 4, maxCards: 4 },
        { name: "No ACES", description: "Each A = 30 pts", pointsPerCard: 30, defaultMaxCards: 4, maxCards: 4 },
        { name: "No QUEENS", description: "Each Q = 30 pts", pointsPerCard: 30, defaultMaxCards: 4, maxCards: 4 },
        { name: "No One-Eyed / KD", description: "Each J♠, J♥, or K♦ = 40 pts", pointsPerCard: 40, defaultMaxCards: 3, maxCards: 3 },
        { name: "No KING of SPADES", description: "If you took K♠, enter 1 = 75 pts", pointsPerCard: 75, defaultMaxCards: 1, maxCards: 1 },
        { name: "No LAST TRICK", description: "If you took last trick, enter 1 = 75 pts", pointsPerCard: 75, defaultMaxCards: 1, maxCards: 1 },
        { name: "All of the Above (per-rule)", description: "Totals from the All-of-the-Above details grid.", pointsPerCard: null, defaultMaxCards: null, maxCards: null }
      ];

      const playerColors = [
        "#f97316", "#22c55e", "#3b82f6", "#e11d48",
        "#a855f7", "#14b8a6", "#eab308", "#f97373"
      ];

      // By default, all first 11 rules enabled; All of the Above always enabled
      let includedRules = rounds.map(() => true);

      const headerRow = document.getElementById("headerRow");
      const headerRowSticky = document.getElementById("headerRowSticky");
      const roundsBody = document.getElementById("roundsBody");

      const playerCountInput = document.getElementById("playerCount");
      const buildBtn = document.getElementById("buildBtn");
      const resetBtn = document.getElementById("resetBtn");

      const scoreTable = document.getElementById("scoreTable");
      const settingsGrid = document.getElementById("settingsGrid");
      const restoreDefaultsBtn = document.getElementById("restoreDefaultsBtn");
      const deckCountSelect = document.getElementById("deckCount");
      const settingsCardEl = document.getElementById("settingsCard");
      const toggleSettingsBtn = document.getElementById("toggleSettingsBtn");
      const playerNamesContainer = document.getElementById("playerNamesContainer");
      const cardRemovalHint = document.getElementById("cardRemovalHint");

      const allDetailsCard = document.getElementById("allDetailsCard");
      const toggleAllDetailsBtn = document.getElementById("toggleAllDetailsBtn");
      const allHeadRow = document.getElementById("allHeadRow");
      const allHeadRowSticky = document.getElementById("allHeadRowSticky");
      const allRulesBody = document.getElementById("allRulesBody");
      const rulesGrid = document.getElementById("rulesGrid");

      const tableBodyScroll = document.getElementById("tableBodyScroll");
      const tableHeaderScroll = document.getElementById("tableHeaderScroll");
      const allBodyScroll = document.getElementById("allBodyScroll");
      const allHeaderScroll = document.getElementById("allHeaderScroll");

      const versionLabel = document.getElementById("versionLabel");
      if (versionLabel) versionLabel.textContent = APP_VERSION;

      let playerCount = 4;
      let deckCount = 1;

      /* ---------------------- Player Names Helpers ---------------------- */

      function getCurrentPlayerNamesFromSettings() {
        const inputs = playerNamesContainer.querySelectorAll("input[data-player-name]");
        const names = [];
        inputs.forEach((input, idx) => {
          const val = input.value.trim();
          names[idx] = val || `Player ${idx + 1}`;
        });
        return names;
      }

      function buildPlayerNameInputs(existingNames) {
        playerNamesContainer.innerHTML = "";
        const baseNames = existingNames || [];

        for (let p = 0; p < playerCount; p++) {
          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.textContent = `Player ${p + 1}`;

          const input = document.createElement("input");
          input.type = "text";
          input.dataset.playerName = String(p);
          input.placeholder = `Player ${p + 1}`;
          input.value = baseNames[p] || `Player ${p + 1}`;
          input.addEventListener("input", () => {
            syncHeaderNamesFromSettings();
            saveState();
          });

          playerNamesContainer.appendChild(labelDiv);
          playerNamesContainer.appendChild(input);
        }

        syncHeaderNamesFromSettings();
      }

      function syncHeaderNamesFromSettings() {
        const names = getCurrentPlayerNamesFromSettings();

        // Main header + sticky header
        document.querySelectorAll(".player-name-text").forEach((node, idx) => {
          if (names[idx]) node.textContent = names[idx];
        });

        // All-of-the-Above header cells
        allHeadRow.querySelectorAll("th[data-all-player]").forEach((th, idx) => {
          if (names[idx]) th.textContent = names[idx];
        });
        allHeadRowSticky.querySelectorAll("th[data-all-player]").forEach((th, idx) => {
          if (names[idx]) th.textContent = names[idx];
        });
      }

      /* ---------------------- Card Removal Hint ---------------------- */

      function updateCardRemovalHint() {
        if (!cardRemovalHint) return;

        let msg = "";
        const pc = playerCount;
        const dc = deckCount;

        if (pc === 3) {
          msg = "3 players: use 1 deck. Remove all clubs (13 cards) before dealing. Each player gets 13 cards.";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 4) {
          msg = "4 players: use 1 deck. No cards removed (perfect deal: 13 cards each).";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 5) {
          msg = "5 players: use 1 deck. Remove the 2♣ and 2♦ (2 cards total), then deal 10 cards to each player.";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 6) {
          msg = "6 players: use 2 decks. Remove one full suit of clubs and one full suit of diamonds (26 cards total), then deal 13 cards to each player.";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else if (pc === 7) {
          msg = "7 players: use 2 decks. Remove one full suit of clubs (13 cards), then deal 13 cards to each player.";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else if (pc === 8) {
          msg = "8 players: use 2 decks. No cards removed (perfect deal: 13 cards each).";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else {
          msg = "No specific card-removal rule for this player count. Use any deck setup you like.";
        }

        cardRemovalHint.textContent = msg;
      }

      /* ---------------------- Rule Toggles UI ---------------------- */

      function buildRulesUI() {
        if (!rulesGrid) return;
        rulesGrid.innerHTML = "";

        for (let idx = 0; idx < rounds.length - 1; idx++) {
          const round = rounds[idx];

          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.innerHTML = `<span>${idx + 1}. ${round.name}</span>`;

          const wrapper = document.createElement("div");
          wrapper.style.display = "flex";
          wrapper.style.alignItems = "center";
          wrapper.style.justifyContent = "flex-end";
          wrapper.style.gap = "0.35rem";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.dataset.ruleToggle = String(idx);
          checkbox.checked = includedRules[idx];

          const span = document.createElement("span");
          span.style.fontSize = "0.75rem";
          span.style.color = "var(--text-muted)";
          span.textContent = "Use";

          checkbox.addEventListener("change", () => {
            includedRules[idx] = checkbox.checked;
            saveState();

            buildRoundsBody();
            buildAllHandGrid();
            updateAllHandTotals();
            updateScores();
            syncStickyHeaderWidths();
          });

          wrapper.appendChild(checkbox);
          wrapper.appendChild(span);

          rulesGrid.appendChild(labelDiv);
          rulesGrid.appendChild(wrapper);
        }
      }

      /* ---------------------- LocalStorage Helpers ---------------------- */

      function saveState() {
        const state = {
          playerCount,
          players: getCurrentPlayerNamesFromSettings(),
          scores: {},
          roundMaxCards: [],
          deckCount,
          allHand: {},
          includedRules: includedRules.slice()
        };

        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          const r = input.dataset.round;
          const p = input.dataset.player;
          const key = `${r}_${p}`;
          state.scores[key] = input.value || "";
        });

        rounds.forEach((round, idx) => {
          state.roundMaxCards[idx] = round.maxCards;
        });

        const allInputs = allRulesBody.querySelectorAll("input[data-all-rule]");
        allInputs.forEach((input) => {
          const rule = input.dataset.allRule;
          const player = input.dataset.player;
          if (!state.allHand[rule]) state.allHand[rule] = {};
          state.allHand[rule][player] = input.value || "";
        });

        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      function loadState() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        try { return JSON.parse(raw); } catch { return null; }
      }

      function applyLoadedState(state) {
        if (!state) return;

        if (state.deckCount != null) {
          const dc = parseInt(state.deckCount, 10);
          if (!isNaN(dc) && dc >= 1) deckCount = dc;
        }
        deckCountSelect.value = String(deckCount);

        if (Array.isArray(state.roundMaxCards)) {
          state.roundMaxCards.forEach((val, idx) => {
            if (idx < rounds.length && val != null) {
              const v = parseInt(val, 10);
              if (!isNaN(v) && v >= 0) rounds[idx].maxCards = v;
            }
          });
        } else {
          applyDeckCountToDefaults();
        }

        if (Array.isArray(state.includedRules)) {
          includedRules = state.includedRules.slice();
        } else {
          includedRules = rounds.map(() => true);
        }

        playerCount = state.playerCount || 4;
        playerCountInput.value = playerCount;

        buildPlayerHeaders();
        buildRoundsBody();
        buildSettingsUI();
        buildRulesUI();
        buildAllHandGrid();
        buildPlayerNameInputs(state.players || []);
        updateCardRemovalHint();

        // Normal round inputs
        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          const key = `${input.dataset.round}_${input.dataset.player}`;
          if (state.scores[key] !== undefined) input.value = state.scores[key];
        });

        // All-of-the-Above per-rule grid
        const allHand = state.allHand || {};
        const allInputs = allRulesBody.querySelectorAll("input[data-all-rule]");
        allInputs.forEach((input) => {
          const r = input.dataset.allRule;
          const p = input.dataset.player;
          const val = allHand[r] && allHand[r][p];
          if (val !== undefined) input.value = val;
        });

        updateAllHandTotals();
        updateScores();
        updateSettingsInputsFromRounds();

        syncStickyHeaderWidths();
      }

      /* ---------------------- Deck & Defaults ---------------------- */

      function applyDeckCountToDefaults() {
        rounds.forEach((round) => {
          if (round.defaultMaxCards != null) {
            round.maxCards = round.defaultMaxCards * deckCount;
          }
        });
      }

      function restoreDefaults() {
        applyDeckCountToDefaults();
        updateSettingsInputsFromRounds();
        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        updateScores();
        saveState();
        syncStickyHeaderWidths();
      }

      /* ---------------------- Settings UI ---------------------- */

      function buildSettingsUI() {
        settingsGrid.innerHTML = "";

        rounds.forEach((round, idx) => {
          if (round.defaultMaxCards == null && round.maxCards == null) return;

          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.innerHTML = `<span>${idx + 1}. ${round.name}</span>`;

          const input = document.createElement("input");
          input.type = "number";
          input.min = "0";
          input.step = "1";
          input.dataset.roundSettings = String(idx);
          input.value = round.maxCards != null ? round.maxCards : 0;

          input.addEventListener("input", () => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            round.maxCards = val;
            input.value = String(val);

            enforceAllRoundLimits(idx);
            enforceAllHandLimitsForRule(idx);
            updateAllHandTotals();
            updateScores();
            saveState();
            syncStickyHeaderWidths();
          });

          settingsGrid.appendChild(labelDiv);
          settingsGrid.appendChild(input);
        });
      }

      function updateSettingsInputsFromRounds() {
        const inputs = settingsGrid.querySelectorAll("input[type='number'][data-round-settings]");
        inputs.forEach((input) => {
          const idx = parseInt(input.dataset.roundSettings, 10);
          const round = rounds[idx];
          if (!round) return;
          if (round.maxCards != null) input.value = round.maxCards;
        });
      }

      /* ---------------------- UI Building ---------------------- */

      function clampPlayerCount(n) {
        if (isNaN(n)) return 4;
        return Math.min(Math.max(n, 2), 8);
      }

      function buildPlayerHeaders() {
        // clear both header rows back to the first "Round" cell
        while (headerRow.children.length > 1) headerRow.removeChild(headerRow.lastElementChild);
        while (headerRowSticky.children.length > 1) headerRowSticky.removeChild(headerRowSticky.lastElementChild);

        for (let p = 0; p < playerCount; p++) {
          const makePlayerTh = () => {
            const th = document.createElement("th");
            th.className = "player-header";
            th.dataset.player = String(p);

            const inner = document.createElement("div");
            inner.className = "player-header-inner";
            inner.style.background = `linear-gradient(135deg, ${hexToSoft(playerColors[p])}, ${playerColors[p]})`;

            const nameDiv = document.createElement("div");
            nameDiv.className = "player-name";

            const placeSpan = document.createElement("span");
            placeSpan.className = "player-place";
            placeSpan.textContent = "";

            const nameSpan = document.createElement("span");
            nameSpan.className = "player-name-text";
            nameSpan.textContent = "Player " + (p + 1);

            nameDiv.appendChild(placeSpan);
            nameDiv.appendChild(nameSpan);

            const totalDiv = document.createElement("div");
            totalDiv.className = "player-total";
            totalDiv.textContent = "0";

            inner.appendChild(nameDiv);
            inner.appendChild(totalDiv);
            th.appendChild(inner);
            return th;
          };

          headerRow.appendChild(makePlayerTh());
          headerRowSticky.appendChild(makePlayerTh());
        }

        syncHeaderNamesFromSettings();
      }

      function buildRoundsBody() {
        roundsBody.innerHTML = "";

        rounds.forEach((round, rIndex) => {
          if (rIndex < rounds.length - 1 && !includedRules[rIndex]) return;

          const tr = document.createElement("tr");

          const th = document.createElement("th");
          th.className = "round-header";

          const titleDiv = document.createElement("div");
          titleDiv.className = "round-title";

          const idxSpan = document.createElement("span");
          idxSpan.className = "round-index";
          idxSpan.textContent = String(rIndex + 1);

          const titleText = document.createElement("span");
          titleText.textContent = round.name;

          titleDiv.appendChild(idxSpan);
          titleDiv.appendChild(titleText);

          const descDiv = document.createElement("div");
          descDiv.className = "round-desc";
          descDiv.textContent = round.description;

          th.appendChild(titleDiv);
          th.appendChild(descDiv);

          const totalDiv = document.createElement("div");
          totalDiv.className = "round-total";
          totalDiv.dataset.round = String(rIndex);
          if (round.maxCards != null) {
            totalDiv.textContent = `0 / ${round.maxCards} cards`;
            totalDiv.classList.add("incomplete");
          } else {
            totalDiv.textContent = "";
          }
          th.appendChild(totalDiv);

          tr.appendChild(th);

          for (let p = 0; p < playerCount; p++) {
            const td = document.createElement("td");
            const wrapper = document.createElement("div");
            wrapper.className = "cell-input";

            const input = document.createElement("input");
            input.type = "number";
            input.min = "0";
            input.inputMode = "numeric";
            input.pattern = "[0-9]*";
            input.dataset.round = String(rIndex);
            input.dataset.player = String(p);

            const note = document.createElement("div");
            note.className = "cell-note";
            note.textContent = "0 pts";

            if (rIndex === rounds.length - 1) {
              input.readOnly = true;
              input.addEventListener("focus", (e) => e.target.blur());
              wrapper.appendChild(input);
              wrapper.appendChild(note);
            } else {
              input.addEventListener("input", () => {
                enforceRoundLimitForInput(input);
                updateScores();
                saveState();
              });
              wrapper.appendChild(input);
              wrapper.appendChild(note);
            }

            td.appendChild(wrapper);
            tr.appendChild(td);
          }

          roundsBody.appendChild(tr);
        });
      }

      function buildAllHandGrid() {
        // build BOTH header rows (hidden + sticky clone)
        while (allHeadRow.children.length > 1) allHeadRow.removeChild(allHeadRow.lastElementChild);
        while (allHeadRowSticky.children.length > 1) allHeadRowSticky.removeChild(allHeadRowSticky.lastElementChild);

        const names = getCurrentPlayerNamesFromSettings();
        for (let p = 0; p < playerCount; p++) {
          const makeTh = () => {
            const th = document.createElement("th");
            th.dataset.allPlayer = String(p);
            th.textContent = names[p] || `P${p + 1}`;
            return th;
          };
          allHeadRow.appendChild(makeTh());
          allHeadRowSticky.appendChild(makeTh());
        }

        // Body
        allRulesBody.innerHTML = "";
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;

          const round = rounds[rIndex];
          const tr = document.createElement("tr");

          const th = document.createElement("th");
          th.className = "round-header";
          th.innerHTML =
            `<div class="round-title">${rIndex + 1}. ${round.name}</div>` +
            `<div class="round-desc">×${round.pointsPerCard} pts</div>` +
            `<div class="round-total all-round-total" data-all-round="${rIndex}"></div>`;
          tr.appendChild(th);

          for (let p = 0; p < playerCount; p++) {
            const td = document.createElement("td");
            const wrapper = document.createElement("div");
            wrapper.className = "cell-input";

            const input = document.createElement("input");
            input.type = "number";
            input.min = "0";
            input.step = "1";
            input.inputMode = "numeric";
            input.pattern = "[0-9]*";
            input.dataset.allRule = String(rIndex);
            input.dataset.player = String(p);
            input.addEventListener("input", () => {
              enforceAllHandLimitForInput(input);
              updateAllHandTotals();
              saveState();
            });

            const note = document.createElement("div");
            note.className = "cell-note";
            note.textContent = "0 pts";

            wrapper.appendChild(input);
            wrapper.appendChild(note);
            td.appendChild(wrapper);
            tr.appendChild(td);
          }

          allRulesBody.appendChild(tr);
        }

        // init indicators
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;
          const round = rounds[rIndex];
          const indicator = document.querySelector(`.all-round-total[data-all-round="${rIndex}"]`);
          if (!indicator || round.maxCards == null) continue;
          indicator.classList.remove("ok", "incomplete");
          indicator.textContent = `0 / ${round.maxCards} cards`;
          indicator.classList.add("incomplete");
        }

        syncHeaderNamesFromSettings();
      }

      /* ---------------------- Sticky header syncing ---------------------- */

      function syncStickyHeaderWidths() {
        syncMainStickyHeaderWidths();
        syncAllStickyHeaderWidths();
      }

      function syncMainStickyHeaderWidths() {
        const firstRow = roundsBody.querySelector("tr");
        if (!firstRow) return;

        const headerCells = Array.from(headerRowSticky.children);
        if (headerCells.length === 0) return;

        const rowHeaderCell = firstRow.querySelector("th.round-header");
        const rowDataCells = Array.from(firstRow.querySelectorAll("td"));

        const widths = [];
        if (rowHeaderCell) widths.push(rowHeaderCell.getBoundingClientRect().width);
        rowDataCells.forEach(td => widths.push(td.getBoundingClientRect().width));

        if (widths.length !== headerCells.length) return;

        requestAnimationFrame(() => {
          for (let i = 0; i < headerCells.length; i++) {
            const w = widths[i];
            headerCells[i].style.width = w + "px";
            headerCells[i].style.minWidth = w + "px";
            headerCells[i].style.maxWidth = w + "px";
          }
        });
      }

      function syncAllStickyHeaderWidths() {
        const firstRow = allRulesBody.querySelector("tr");
        if (!firstRow) return;

        const headerCells = Array.from(allHeadRowSticky.children);
        if (headerCells.length === 0) return;

        const rowHeaderCell = firstRow.querySelector("th.round-header");
        const rowDataCells = Array.from(firstRow.querySelectorAll("td"));

        // include the first "Rule" sticky header cell already present in sticky row
        // Note: sticky row includes the first th.round-header plus player ths.
        const stickyRowCells = Array.from(allHeadRowSticky.parentElement.children); // not reliable
        // We'll just measure widths and apply to the actual cells in the sticky row:
        const stickyCells = Array.from(allHeadRowSticky.children);
        // But we need the first "Rule" cell too: it's the first child of the sticky row already.
        // allHeadRowSticky includes ALL ths including the first "Rule" th? No: it started with one in HTML and we append players.
        // So include that first cell:
        const stickyRow = document.getElementById("allHeadRowSticky");
        const stickyAllCells = Array.from(stickyRow.children);

        const widths = [];
        if (rowHeaderCell) widths.push(rowHeaderCell.getBoundingClientRect().width);
        rowDataCells.forEach(td => widths.push(td.getBoundingClientRect().width));

        if (widths.length !== stickyAllCells.length) return;

        requestAnimationFrame(() => {
          for (let i = 0; i < stickyAllCells.length; i++) {
            const w = widths[i];
            stickyAllCells[i].style.width = w + "px";
            stickyAllCells[i].style.minWidth = w + "px";
            stickyAllCells[i].style.maxWidth = w + "px";
          }
        });
      }

      /* ---------------------- Card-limit Enforcement ---------------------- */

      function enforceRoundLimitForInput(input) {
        const rIndex = parseInt(input.dataset.round, 10);
        const round = rounds[rIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRound = roundsBody.querySelectorAll(`input[data-round="${rIndex}"]`);

        let sumOthers = 0;
        inputsThisRound.forEach((el) => {
          if (el === input) return;
          const v = parseInt(el.value || "0", 10);
          if (!isNaN(v) && v > 0) sumOthers += v;
        });

        let val = parseInt(input.value || "0", 10);
        if (isNaN(val) || val < 0) val = 0;

        const allowedForThis = Math.max(0, max - sumOthers);
        if (val > allowedForThis) {
          val = allowedForThis;
          input.value = val ? String(val) : "";
        }
      }

      function enforceAllRoundLimits(onlyRoundIndex = null) {
        const roundsToCheck =
          onlyRoundIndex == null
            ? rounds.map((_, idx) => idx)
            : [onlyRoundIndex];

        roundsToCheck.forEach((rIndex) => {
          const round = rounds[rIndex];
          if (!round || round.maxCards == null) return;

          const max = round.maxCards;
          const inputsThisRound = roundsBody.querySelectorAll(`input[data-round="${rIndex}"]`);

          let total = 0;
          inputsThisRound.forEach((input) => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            total += val;
          });

          if (total <= max) return;

          let remaining = max;
          inputsThisRound.forEach((input) => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            if (val > remaining) val = remaining;
            input.value = val ? String(val) : "";
            remaining -= val;
          });
        });
      }

      function enforceAllHandLimitForInput(input) {
        const rIndex = parseInt(input.dataset.allRule, 10);
        const round = rounds[rIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRule = allRulesBody.querySelectorAll(`input[data-all-rule="${rIndex}"]`);

        let sumOthers = 0;
        inputsThisRule.forEach((el) => {
          if (el === input) return;
          const v = parseInt(el.value || "0", 10);
          if (!isNaN(v) && v > 0) sumOthers += v;
        });

        let val = parseInt(input.value || "0", 10);
        if (isNaN(val) || val < 0) val = 0;

        const allowedForThis = Math.max(0, max - sumOthers);
        if (val > allowedForThis) {
          val = allowedForThis;
          input.value = val ? String(val) : "";
        }
      }

      function enforceAllHandLimitsForRule(ruleIndex) {
        const round = rounds[ruleIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRule = allRulesBody.querySelectorAll(`input[data-all-rule="${ruleIndex}"]`);

        let total = 0;
        inputsThisRule.forEach((input) => {
          let val = parseInt(input.value || "0", 10);
          if (isNaN(val) || val < 0) val = 0;
          total += val;
        });

        if (total <= max) return;

        let remaining = max;
        inputsThisRule.forEach((input) => {
          let val = parseInt(input.value || "0", 10);
          if (isNaN(val) || val < 0) val = 0;
          if (val > remaining) val = remaining;
          input.value = val ? String(val) : "";
          remaining -= val;
        });
      }

      function enforceAllHandLimitsForAll() {
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          enforceAllHandLimitsForRule(rIndex);
        }
      }

      /* ---------------------- Score Logic + Places ---------------------- */

      function resetScores() {
        scoreTable.querySelectorAll("tbody input[type='number']").forEach((input) => input.value = "");
        scoreTable.querySelectorAll(".cell-note").forEach((n) => {
          n.textContent = "0 pts";
          n.classList.remove("highlight");
        });

        allRulesBody.querySelectorAll("input[data-all-rule]").forEach((input) => input.value = "");
        allRulesBody.querySelectorAll(".cell-note").forEach((n) => {
          n.textContent = "0 pts";
          n.classList.remove("highlight");
        });

        updateAllHandTotals();

        document.querySelectorAll(".player-total").forEach((t) => (t.textContent = "0"));
        document.querySelectorAll(".player-header-inner").forEach((h) => h.classList.remove("winner"));
        document.querySelectorAll(".player-place").forEach((b) => (b.textContent = ""));

        document.querySelectorAll(".round-total[data-round]").forEach((el) => {
          const rIndex = parseInt(el.dataset.round || "-1", 10);
          const round = rounds[rIndex];
          el.classList.remove("ok", "incomplete");
          if (round && round.maxCards != null) {
            el.textContent = `0 / ${round.maxCards} cards`;
            el.classList.add("incomplete");
          } else {
            el.textContent = "";
          }
        });

        localStorage.removeItem(STORAGE_KEY);
        syncStickyHeaderWidths();
      }

      function updatePlaces(totals) {
        const badges = document.querySelectorAll(".player-place");
        if (!badges || badges.length === 0) return;

        const anyNonZero = totals.some(v => v !== 0);
        if (!anyNonZero) {
          badges.forEach(b => b.textContent = "");
          return;
        }

        const items = totals.map((t, idx) => ({ idx, total: t }));
        items.sort((a, b) => a.total - b.total || a.idx - b.idx);

        const rankByIdx = new Array(totals.length).fill(0);
        const tieByIdx = new Array(totals.length).fill(false);

        // compute ranks (1-based), ties share same rank
        let currentRank = 1;
        for (let i = 0; i < items.length; i++) {
          if (i > 0 && items[i].total !== items[i - 1].total) {
            currentRank = i + 1;
          }
          rankByIdx[items[i].idx] = currentRank;
        }

        // mark ties
        const totalToPlayers = new Map();
        totals.forEach((t, idx) => {
          if (!totalToPlayers.has(t)) totalToPlayers.set(t, []);
          totalToPlayers.get(t).push(idx);
        });
        totalToPlayers.forEach((arr) => {
          if (arr.length > 1) arr.forEach(i => tieByIdx[i] = true);
        });

        badges.forEach((b, idx) => {
          const r = rankByIdx[idx] || (idx + 1);
          b.textContent = (tieByIdx[idx] ? "T#" : "#") + r;
        });
      }

      function updateScores() {
        const totals = new Array(playerCount).fill(0);
        const roundSums = new Array(rounds.length).fill(0);

        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          const r = parseInt(input.dataset.round, 10);
          const p = parseInt(input.dataset.player, 10);
          const round = rounds[r];
          const count = parseInt(input.value || "0", 10) || 0;

          if (!isNaN(count) && count > 0 && round.maxCards != null) {
            roundSums[r] += count;
          }

          let points = 0;
          if (round.pointsPerCard === null) points = count;
          else points = count * round.pointsPerCard;

          totals[p] += points;

          const note = input.parentElement.querySelector(".cell-note");
          if (note) {
            note.textContent = points + " pts";
            note.classList.toggle("highlight", points > 0);
          }
        });

        updateRoundTotals(roundSums);

        document.querySelectorAll(".player-total").forEach((node, idx) => {
          node.textContent = totals[idx];
        });

        const headers = document.querySelectorAll(".player-header-inner");
        headers.forEach((h) => h.classList.remove("winner"));

        const anyNonZero = totals.some((v) => v !== 0);
        if (anyNonZero) {
          const minTotal = Math.min(...totals);
          totals.forEach((t, idx) => {
            if (t === minTotal) headers[idx].classList.add("winner");
          });
        }

        updatePlaces(totals);
      }

      function updateRoundTotals(roundSums) {
        roundSums.forEach((sum, rIndex) => {
          const round = rounds[rIndex];
          const el = document.querySelector(`.round-total[data-round="${rIndex}"]`);
          if (!el || !round) return;

          el.classList.remove("ok", "incomplete");

          if (round.maxCards == null) {
            el.textContent = "";
            return;
          }

          el.textContent = `${sum} / ${round.maxCards} cards`;
          if (sum === round.maxCards) el.classList.add("ok");
          else el.classList.add("incomplete");
        });
      }

      function updateAllHandTotals() {
        const totalsByPlayer = new Array(playerCount).fill(0);
        const ruleTotals = new Array(rounds.length - 1).fill(0);

        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;

          const rule = rounds[rIndex];
          const inputsThisRule = allRulesBody.querySelectorAll(`input[data-all-rule="${rIndex}"]`);

          inputsThisRule.forEach((input) => {
            const p = parseInt(input.dataset.player, 10);
            const cnt = parseInt(input.value || "0", 10) || 0;
            const pts = cnt * (rule.pointsPerCard || 0);
            totalsByPlayer[p] += pts;
            ruleTotals[rIndex] += cnt;

            const note = input.parentElement.querySelector(".cell-note");
            if (note) {
              note.textContent = pts + " pts";
              note.classList.toggle("highlight", pts > 0);
            }
          });
        }

        // Update "X / N cards" per rule row
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;
          const round = rounds[rIndex];
          const indicator = document.querySelector(`.all-round-total[data-all-round="${rIndex}"]`);
          if (!indicator || round.maxCards == null) continue;
          indicator.classList.remove("ok", "incomplete");
          indicator.textContent = `${ruleTotals[rIndex]} / ${round.maxCards} cards`;
          if (ruleTotals[rIndex] === round.maxCards) indicator.classList.add("ok");
          else indicator.classList.add("incomplete");
        }

        // Push totals into Round 12 row
        const allRowIndex = rounds.length - 1;
        for (let p = 0; p < playerCount; p++) {
          const mainInput = document.querySelector(`input[data-round="${allRowIndex}"][data-player="${p}"]`);
          if (mainInput) {
            const total = totalsByPlayer[p];
            mainInput.value = total ? String(total) : "";
          }
        }

        updateScores();
        syncStickyHeaderWidths();
      }

      /* ---------------------- Utility ---------------------- */

      function hexToSoft(hex) {
        const base = "#1d4ed8";
        try {
          const c1 = hexToRgb(hex);
          const c2 = hexToRgb(base);
          const mix = {
            r: Math.round((c1.r + c2.r * 1.4) / 2.4),
            g: Math.round((c1.g + c2.g * 1.4) / 2.4),
            b: Math.round((c1.b + c2.b * 1.4) / 2.4)
          };
          return `rgba(${mix.r},${mix.g},${mix.b},0.6)`;
        } catch {
          return "rgba(30,64,175,0.55)";
        }
      }

      function hexToRgb(hex) {
        const c = hex.replace("#", "");
        if (c.length !== 6) return null;
        const v = parseInt(c, 16);
        return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
      }

      /* ---------------------- Event Setup ---------------------- */

      buildBtn.addEventListener("click", () => {
        const desired = clampPlayerCount(parseInt(playerCountInput.value, 10));
        const existingNames = getCurrentPlayerNamesFromSettings();
        playerCount = desired;
        playerCountInput.value = desired;

        buildPlayerHeaders();
        buildRoundsBody();
        buildSettingsUI();
        buildRulesUI();
        buildAllHandGrid();
        buildPlayerNameInputs(existingNames);
        updateCardRemovalHint();

        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        saveState();
        syncStickyHeaderWidths();
      });

      resetBtn.addEventListener("click", resetScores);

      restoreDefaultsBtn.addEventListener("click", () => {
        restoreDefaults();
      });

      deckCountSelect.addEventListener("change", () => {
        const dc = parseInt(deckCountSelect.value, 10);
        deckCount = !isNaN(dc) && dc >= 1 ? dc : 1;

        applyDeckCountToDefaults();
        updateSettingsInputsFromRounds();
        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        updateScores();
        updateCardRemovalHint();
        saveState();
        syncStickyHeaderWidths();
      });

      toggleSettingsBtn.addEventListener("click", () => {
        const nowHidden = settingsCardEl.classList.toggle("hidden");
        toggleSettingsBtn.textContent = nowHidden ? "Show Settings" : "Hide Settings";
      });

      toggleAllDetailsBtn.addEventListener("click", () => {
        const nowHidden = allDetailsCard.classList.toggle("hidden");
        toggleAllDetailsBtn.textContent = nowHidden
          ? "Show All-of-the-Above Grid"
          : "Hide All-of-the-Above Grid";

        // when opening, sync widths after layout
        if (!nowHidden) {
          setTimeout(syncStickyHeaderWidths, 50);
        }
      });

      // ✅ keep sticky headers aligned with horizontal scroll
      if (tableBodyScroll && tableHeaderScroll) {
        tableBodyScroll.addEventListener("scroll", () => {
          tableHeaderScroll.scrollLeft = tableBodyScroll.scrollLeft;
        }, { passive: true });
      }
      if (allBodyScroll && allHeaderScroll) {
        allBodyScroll.addEventListener("scroll", () => {
          allHeaderScroll.scrollLeft = allBodyScroll.scrollLeft;
        }, { passive: true });
      }

      // Re-sync on resize/orientation changes
      window.addEventListener("resize", () => {
        syncStickyHeaderWidths();
      });

      /* ---------------------- Initial Load ---------------------- */

      applyDeckCountToDefaults();
      buildPlayerHeaders();
      buildRoundsBody();
      buildSettingsUI();
      buildRulesUI();
      buildAllHandGrid();
      buildPlayerNameInputs(); // default names
      updateCardRemovalHint();

      const saved = loadState();
      applyLoadedState(saved);

      // One more sync after first paint
      setTimeout(syncStickyHeaderWidths, 50);

    })();
  </script>
</body>
</html>
