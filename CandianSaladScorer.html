<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Canadian Salad Scorekeeper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <style>
    :root {
      --bg: #050816;
      --bg-soft: #0c1224;
      --card: #111827;
      --card-soft: #1f2937;
      --accent: #f97316;
      --accent-soft: rgba(249, 115, 22, 0.14);
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --border-subtle: #1f2933;
      --winner-glow: 0 0 0 2px rgba(52, 211, 153, 0.7);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 50%, #000 100%);
      color: var(--text-main);
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 1rem 0.75rem 2.5rem;
    }

    header {
      text-align: center;
      margin-bottom: 0.5rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.5rem;
      letter-spacing: 0.05em;
    }

    header p {
      margin: 0.35rem 0 0;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .card {
      background: linear-gradient(135deg, rgba(15,23,42,0.96), rgba(17,24,39,0.96));
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,0.15);
      box-shadow: 0 18px 40px rgba(15,23,42,0.65);
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      backdrop-filter: blur(14px);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: space-between;
    }

    .controls-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    .controls label {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .controls input[type="number"] {
      width: 4rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.6rem;
      border: 1px solid var(--border-subtle);
      background: #020617;
      color: var(--text-main);
      font-size: 0.9rem;
      text-align: center;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      background: radial-gradient(circle at top left, #fb923c, #f97316);
      color: #111827;
      box-shadow: 0 10px 25px rgba(249,115,22,0.4);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      cursor: pointer;
    }

    button.secondary {
      background: rgba(15,23,42,0.9);
      color: var(--text-muted);
      border: 1px solid rgba(148,163,184,0.5);
      box-shadow: none;
    }

    button.ghost {
      background: transparent;
      color: var(--text-muted);
      border: 1px dashed rgba(148,163,184,0.6);
      box-shadow: none;
    }

    button.small {
      padding: 0.25rem 0.7rem;
      font-size: 0.75rem;
    }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(249,115,22,0.4);
    }

    .hint {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 0.3rem;
    }

    .hidden {
      display: none;
    }

    /* Settings section */
    .settings-card-title {
      font-size: 0.9rem;
      font-weight: 700;
      margin-bottom: 0.35rem;
    }

    .settings-subtitle {
      font-size: 0.72rem;
      color: var(--text-muted);
      margin-bottom: 0.35rem;
    }

    .settings-section {
      margin-bottom: 0.75rem;
      border-radius: 0.75rem;
      padding: 0.6rem;
      background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,0.7));
      border: 1px solid rgba(31,41,55,0.8);
    }

    .settings-section-title {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 0.35rem;
    }

    .settings-actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.35rem;
    }

    .settings-actions label {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    .settings-actions select {
      padding: 0.2rem 0.5rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(148,163,184,0.8);
      background: #020617;
      color: var(--text-main);
      font-size: 0.8rem;
    }

    .settings-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 0.35rem 0.75rem;
      align-items: center;
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }

    .settings-round-label {
      color: var(--text-muted);
    }

    .settings-round-label span {
      color: var(--text-main);
      font-weight: 500;
    }

    .settings-grid input[type="number"],
    .settings-grid input[type="text"] {
      width: 100%;
      max-width: 8rem;
      text-align: left;
      padding: 0.25rem 0.35rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      font-size: 0.75rem;
    }

    .settings-hint {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 0.35rem;
    }

    .settings-toggle-row {
      display: flex;
      justify-content: flex-end;
      margin: 0.5rem 0;
    }

    /* Score table */
    .table-wrapper {
      margin-top: 0.6rem;
      border-radius: 0.95rem;
      border: 1px solid rgba(148,163,184,0.2);
      overflow: hidden;
      background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,1));
    }

    .table-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 520px;
    }

    thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(15,23,42,0.98);
      backdrop-filter: blur(18px);
    }

    th, td {
      padding: 0.35rem 0.4rem;
      text-align: center;
      border-bottom: 1px solid rgba(31,41,55,0.9);
      font-size: 0.78rem;
    }

    th.round-header {
      text-align: left;
      width: 28%;
      position: sticky;
      left: 0;
      z-index: 8;
      background: rgba(17,24,39,0.96);
      border-right: 1px solid rgba(31,41,55,0.9);
    }

    th.round-header .round-title {
      font-weight: 600;
      font-size: 0.8rem;
    }

    th.round-header .round-desc {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 0.1rem;
    }

    .round-total {
      font-size: 0.7rem;
      margin-top: 0.15rem;
      color: var(--text-muted);
    }

    .round-total.ok {
      color: #4ade80;
      font-weight: 600;
    }

    .round-total.incomplete {
      color: #fbbf24;
      font-weight: 500;
    }

    th.player-header {
      min-width: 90px;
    }

    .player-header-inner {
      background: linear-gradient(135deg, rgba(30,64,175,0.45), rgba(15,118,110,0.65));
      border-radius: 0.9rem;
      padding: 0.2rem 0.35rem 0.25rem;
      border: 1px solid rgba(148,163,184,0.5);
      position: relative;
      box-shadow: 0 8px 16px rgba(15,23,42,0.55);
    }

    .player-header-inner::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 2px solid transparent;
      background: linear-gradient(135deg, rgba(249,115,22,0.8), rgba(59,130,246,0.6)) border-box;
      mask:
        linear-gradient(#000 0 0) padding-box,
        linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
              mask-composite: exclude;
      opacity: 0.25;
      pointer-events: none;
    }

    .player-header-inner .player-name {
      font-size: 0.75rem;
      font-weight: 600;
      line-height: 1.1;
    }

    .player-header-inner .player-total {
      font-size: 0.95rem;
      font-weight: 700;
      margin-top: 0.1rem;
      text-shadow: 0 1px 3px rgba(0,0,0,0.7);
    }

    .player-header-inner.winner {
      box-shadow: var(--winner-glow), 0 14px 30px rgba(16,185,129,0.55);
      border-color: rgba(45,212,191,0.8);
    }

    .player-header-inner.winner::before {
      background: linear-gradient(135deg, rgba(45,212,191,0.95), rgba(22,163,74,0.9)) border-box;
      opacity: 0.95;
    }

    .player-header-inner.winner .player-total {
      color: #bbf7d0;
    }

    .round-index {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.1rem;
      height: 1.1rem;
      border-radius: 999px;
      background: rgba(55,65,81,0.9);
      font-size: 0.6rem;
      margin-right: 0.35rem;
    }

    .cell-input {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.1rem;
    }

    .cell-input input[type="number"] {
      width: 4rem;
      text-align: center;
      border-radius: 0.6rem;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      padding: 0.25rem 0.3rem;
      font-size: 0.8rem;
    }

    .cell-input input[type="number"]:focus {
      outline: 2px solid rgba(249,115,22,0.75);
      outline-offset: 1px;
    }

    .cell-note {
      font-size: 0.68rem;
      color: var(--text-muted);
      min-height: 0.9rem;
    }

    .cell-note.highlight {
      color: #f97316;
      font-weight: 600;
    }

    tfoot td {
      border-top: 1px solid rgba(148,163,184,0.35);
      font-size: 0.75rem;
    }

    .footer-note {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 0.35rem;
      text-align: center;
    }

    @media (max-width: 640px) {
      header h1 {
        font-size: 1.25rem;
      }

      .card {
        padding: 0.7rem;
      }

      th, td {
        padding: 0.3rem 0.35rem;
      }

      .cell-input input[type="number"] {
        width: 3.4rem;
      }

      .settings-grid {
        grid-template-columns: 1.2fr auto;
      }

      .settings-actions {
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Canadian Salad Scorekeeper</h1>
      <p>Tap the bad cards / tricks per player &mdash; scores update automatically.</p>
    </header>

    <div class="settings-toggle-row">
      <button id="toggleSettingsBtn" type="button" class="ghost small">Show Settings</button>
    </div>

    <!-- SETTINGS SECTION (Players + Deck/Round limits + Rules toggles) -->
    <section class="card hidden" id="settingsCard">
      <div class="settings-card-title">Settings</div>
      <div class="settings-subtitle">
        Adjust players, names, decks, round limits, and which rules are used. These are saved on this device.
      </div>

      <!-- Players subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Players</div>
        <div class="controls">
          <div class="controls-group">
            <label for="playerCount">Number of players</label>
            <input type="number" id="playerCount" min="2" max="8" value="4" />
          </div>
          <div class="controls-group">
            <button id="buildBtn" type="button">Apply Players</button>
            <button id="resetBtn" type="button" class="secondary">Reset Scores</button>
          </div>
        </div>
        <p class="hint">
          Enter player names below. Low score wins.
        </p>
        <div id="playerNamesContainer" class="settings-grid" style="margin-top:0.35rem;">
          <!-- Player name inputs inserted here -->
        </div>
        <p class="hint" id="cardRemovalHint"></p>
      </div>

      <!-- Deck / Round limits subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Deck / Round Limits</div>
        <div class="controls" style="margin-bottom:0.5rem;">
          <div class="controls-group">
            <span style="font-size:0.78rem;color:var(--text-muted);">
              Defaults assume a 52-card deck. Card limits scale with number of decks.
            </span>
          </div>
          <div class="settings-actions">
            <label for="deckCount">
              Decks
              <select id="deckCount">
                <option value="1">1 deck</option>
                <option value="2">2 decks</option>
                <option value="3">3 decks</option>
                <option value="4">4 decks</option>
              </select>
            </label>
            <button id="restoreDefaultsBtn" type="button" class="ghost small">Restore Defaults</button>
          </div>
        </div>

        <div class="settings-grid" id="settingsGrid">
          <!-- Rows inserted dynamically -->
        </div>

        <div class="settings-hint">
          Defaults are “per deck” × number of decks. Changing decks recalculates limits; then you can fine-tune per round.
        </div>
      </div>

      <!-- Rules enabled / disabled subsection -->
      <div class="settings-section">
        <div class="settings-section-title">Rules in this game</div>
        <div class="settings-grid" id="rulesGrid">
          <!-- Rule toggles inserted dynamically -->
        </div>
        <div class="settings-hint">
          Uncheck rules you want to skip for a shorter game. Disabled rules disappear from the main table and from the All-of-the-Above grid.
        </div>
      </div>
    </section>

    <!-- SCORE TABLE -->
    <section class="table-wrapper">
      <div class="table-scroll">
        <table id="scoreTable">
          <thead>
            <tr id="headerRow">
              <th class="round-header">
                <div class="round-title">Round</div>
                <div class="round-desc">Objective &amp; penalty per card/event</div>
              </th>
              <!-- Player headers injected here -->
            </tr>
          </thead>
          <tbody id="roundsBody">
            <!-- Rounds injected here -->
          </tbody>
          <tfoot>
            <tr>
              <td colspan="99">
                “All of the Above” uses a per-rule breakdown for that one hand (see grid below). Low score wins.
              </td>
            </tr>
          </tfoot>
        </table>
      </div>
      <div class="footer-note">
        Works offline once opened. Add it to your Android home screen for quick access.
      </div>
    </section>

    <!-- All-of-the-Above details by rule -->
    <div class="settings-toggle-row">
      <button id="toggleAllDetailsBtn" type="button" class="ghost small">Show All-of-the-Above Grid</button>
    </div>
    <section class="card hidden" id="allDetailsCard">
      <div class="settings-card-title">All of the Above – Details by Rule</div>
      <div class="settings-subtitle">
        Enter, by rule, how many “bad” cards/events each player took in the All-of-the-Above hand.
        Each row shows “X / N cards” and totals roll up into Round 12 automatically.
      </div>
      <div class="table-scroll">
        <table>
          <thead>
            <tr id="allHeadRow">
              <th class="round-header">
                <div class="round-title">Rule</div>
                <div class="round-desc">Penalty per card/event</div>
              </th>
              <!-- Player headers inserted here -->
            </tr>
          </thead>
          <tbody id="allRulesBody">
            <!-- Per-rule rows injected here -->
          </tbody>
        </table>
      </div>
    </section>
  </div>

  <script>
    (function () {
      const STORAGE_KEY = "canadianSaladScores_v9";

      // Rounds: defaultMaxCards is per-deck; maxCards is current total after deck scaling.
      const rounds = [
        {
          name: "No RED Cards",
          description: "Each red card (♥ or ♦) = 5 pts",
          pointsPerCard: 5,
          defaultMaxCards: 26,
          maxCards: 26
        },
        {
          name: "No EVEN Cards",
          description: "Each even-ranked card (2,4,6,8,10,Q) = 5 pts",
          pointsPerCard: 5,
          defaultMaxCards: 24,
          maxCards: 24
        },
        {
          name: "No Tricks",
          description: "Each trick taken = 10 pts",
          pointsPerCard: 10,
          defaultMaxCards: 13,
          maxCards: 13
        },
        {
          name: "No HEARTS",
          description: "Each ♥ = 10 pts",
          pointsPerCard: 10,
          defaultMaxCards: 13,
          maxCards: 13
        },
        {
          name: "No FACE Cards",
          description: "Each J, Q, K = 10 pts",
          pointsPerCard: 10,
          defaultMaxCards: 12,
          maxCards: 12
        },
        {
          name: "No SEVENS",
          description: "Each 7 = 30 pts",
          pointsPerCard: 30,
          defaultMaxCards: 4,
          maxCards: 4
        },
        {
          name: "No ACES",
          description: "Each A = 30 pts",
          pointsPerCard: 30,
          defaultMaxCards: 4,
          maxCards: 4
        },
        {
          name: "No QUEENS",
          description: "Each Q = 30 pts",
          pointsPerCard: 30,
          defaultMaxCards: 4,
          maxCards: 4
        },
        {
          name: "No One-Eyed / KD",
          description: "Each J♠, J♥, or K♦ = 40 pts",
          pointsPerCard: 40,
          defaultMaxCards: 3,
          maxCards: 3
        },
        {
          name: "No KING of SPADES",
          description: "If you took K♠, enter 1 = 75 pts",
          pointsPerCard: 75,
          defaultMaxCards: 1,
          maxCards: 1
        },
        {
          name: "No LAST TRICK",
          description: "If you took last trick, enter 1 = 75 pts",
          pointsPerCard: 75,
          defaultMaxCards: 1,
          maxCards: 1
        },
        {
          name: "All of the Above (per-rule)",
          description: "Totals from the All-of-the-Above details grid.",
          pointsPerCard: null,
          defaultMaxCards: null,
          maxCards: null
        }
      ];

      const playerColors = [
        "#f97316", "#22c55e", "#3b82f6", "#e11d48",
        "#a855f7", "#14b8a6", "#eab308", "#f97373"
      ];

      // By default, all first 11 rules enabled; All-of-the-Above (index 11) always enabled
      let includedRules = rounds.map((_, idx) => idx < rounds.length - 1 ? true : true);

      const headerRow = document.getElementById("headerRow");
      const roundsBody = document.getElementById("roundsBody");
      const playerCountInput = document.getElementById("playerCount");
      const buildBtn = document.getElementById("buildBtn");
      const resetBtn = document.getElementById("resetBtn");
      const scoreTable = document.getElementById("scoreTable");
      const settingsGrid = document.getElementById("settingsGrid");
      const restoreDefaultsBtn = document.getElementById("restoreDefaultsBtn");
      const deckCountSelect = document.getElementById("deckCount");
      const settingsCardEl = document.getElementById("settingsCard");
      const toggleSettingsBtn = document.getElementById("toggleSettingsBtn");
      const playerNamesContainer = document.getElementById("playerNamesContainer");
      const cardRemovalHint = document.getElementById("cardRemovalHint");

      const allDetailsCard = document.getElementById("allDetailsCard");
      const toggleAllDetailsBtn = document.getElementById("toggleAllDetailsBtn");
      const allHeadRow = document.getElementById("allHeadRow");
      const allRulesBody = document.getElementById("allRulesBody");
      const rulesGrid = document.getElementById("rulesGrid");

      let playerCount = 4;
      let deckCount = 1;

      /* ---------------------- Player Names Helpers ---------------------- */

      function getCurrentPlayerNamesFromSettings() {
        const inputs = playerNamesContainer.querySelectorAll("input[data-player-name]");
        const names = [];
        inputs.forEach((input, idx) => {
          const val = input.value.trim();
          names[idx] = val || `Player ${idx + 1}`;
        });
        return names;
      }

      function buildPlayerNameInputs(existingNames) {
        playerNamesContainer.innerHTML = "";
        const baseNames = existingNames || [];

        for (let p = 0; p < playerCount; p++) {
          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.textContent = `Player ${p + 1}`;

          const input = document.createElement("input");
          input.type = "text";
          input.dataset.playerName = String(p);
          input.placeholder = `Player ${p + 1}`;
          input.value = baseNames[p] || `Player ${p + 1}`;
          input.addEventListener("input", () => {
            syncHeaderNamesFromSettings();
            saveState();
          });

          playerNamesContainer.appendChild(labelDiv);
          playerNamesContainer.appendChild(input);
        }

        syncHeaderNamesFromSettings();
      }

      function syncHeaderNamesFromSettings() {
        const names = getCurrentPlayerNamesFromSettings();
        const headerNameNodes = document.querySelectorAll(".player-name");
        headerNameNodes.forEach((node, idx) => {
          if (names[idx]) node.textContent = names[idx];
        });

        // Also update All-of-the-Above grid column headers
        const allHeaderCells = allHeadRow.querySelectorAll("th[data-all-player]");
        allHeaderCells.forEach((th, idx) => {
          if (names[idx]) th.textContent = names[idx];
        });
      }

      /* ---------------------- Card Removal Hint ---------------------- */

      function updateCardRemovalHint() {
        if (!cardRemovalHint) return;

        let msg = "";
        const pc = playerCount;
        const dc = deckCount;

        if (pc === 3) {
          msg = "3 players: use 1 deck. Remove all clubs (13 cards) before dealing. Each player gets 13 cards.";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 4) {
          msg = "4 players: use 1 deck. No cards removed (perfect deal: 13 cards each).";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 5) {
          msg = "5 players: use 1 deck. Remove the 2♣ and 2♦ (2 cards total), then deal 10 cards to each player.";
          if (dc !== 1) msg += " Tip: set Decks to 1 above.";
        } else if (pc === 6) {
          msg = "6 players: use 2 decks. Remove one full suit of clubs and one full suit of diamonds (26 cards total), then deal 13 cards to each player.";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else if (pc === 7) {
          msg = "7 players: use 2 decks. Remove one full suit of clubs (13 cards), then deal 13 cards to each player.";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else if (pc === 8) {
          msg = "8 players: use 2 decks. No cards removed (perfect deal: 13 cards each).";
          if (dc !== 2) msg += " Tip: set Decks to 2 above.";
        } else {
          msg = "No specific card-removal rule for this player count. Use any deck setup you like.";
        }

        cardRemovalHint.textContent = msg;
      }

      /* ---------------------- Rule Toggles UI ---------------------- */

      function buildRulesUI() {
        if (!rulesGrid) return;
        rulesGrid.innerHTML = "";

        for (let idx = 0; idx < rounds.length - 1; idx++) {
          const round = rounds[idx];

          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.innerHTML = `<span>${idx + 1}. ${round.name}</span>`;

          const wrapper = document.createElement("div");
          wrapper.style.display = "flex";
          wrapper.style.alignItems = "center";
          wrapper.style.justifyContent = "flex-end";
          wrapper.style.gap = "0.35rem";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.dataset.ruleToggle = String(idx);
          checkbox.checked = includedRules[idx];

          const span = document.createElement("span");
          span.style.fontSize = "0.75rem";
          span.style.color = "var(--text-muted)";
          span.textContent = "Use";

          checkbox.addEventListener("change", () => {
            includedRules[idx] = checkbox.checked;
            saveState();
            const saved = loadState();
            if (saved) {
              saved.includedRules = includedRules.slice();
              localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
              applyLoadedState(saved);
            } else {
              buildRoundsBody();
              buildAllHandGrid();
              updateAllHandTotals();
              updateScores();
            }
          });

          wrapper.appendChild(checkbox);
          wrapper.appendChild(span);

          rulesGrid.appendChild(labelDiv);
          rulesGrid.appendChild(wrapper);
        }
      }

      /* ---------------------- LocalStorage Helpers ---------------------- */

      function saveState() {
        const state = {
          playerCount,
          players: getCurrentPlayerNamesFromSettings(),
          scores: {},
          roundMaxCards: [],
          deckCount,
          allHand: {},
          includedRules: includedRules.slice()
        };

        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          const r = input.dataset.round;
          const p = input.dataset.player;
          const key = `${r}_${p}`;
          state.scores[key] = input.value || "";
        });

        rounds.forEach((round, idx) => {
          state.roundMaxCards[idx] = round.maxCards;
        });

        // All-of-the-Above per-rule grid
        const allInputs = allRulesBody.querySelectorAll("input[data-all-rule]");
        allInputs.forEach((input) => {
          const rule = input.dataset.allRule;
          const player = input.dataset.player;
          if (!state.allHand[rule]) state.allHand[rule] = {};
          state.allHand[rule][player] = input.value || "";
        });

        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      function loadState() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        try {
          return JSON.parse(raw);
        } catch {
          return null;
        }
      }

      function applyLoadedState(state) {
        if (!state) return;

        if (state.deckCount != null) {
          const dc = parseInt(state.deckCount, 10);
          if (!isNaN(dc) && dc >= 1) {
            deckCount = dc;
          }
        }
        deckCountSelect.value = String(deckCount);

        if (Array.isArray(state.roundMaxCards)) {
          state.roundMaxCards.forEach((val, idx) => {
            if (idx < rounds.length && val != null) {
              const v = parseInt(val, 10);
              if (!isNaN(v) && v >= 0) {
                rounds[idx].maxCards = v;
              }
            }
          });
        } else {
          applyDeckCountToDefaults();
        }

        if (Array.isArray(state.includedRules)) {
          includedRules = state.includedRules.slice();
        } else {
          includedRules = rounds.map((_, idx) => idx < rounds.length - 1 ? true : true);
        }

        playerCount = state.playerCount || 4;
        playerCountInput.value = playerCount;

        buildPlayerHeaders();
        buildRoundsBody();
        buildSettingsUI();
        buildRulesUI();
        buildAllHandGrid();
        buildPlayerNameInputs(state.players || []);
        updateCardRemovalHint();

        // Normal round inputs
        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          const key = `${input.dataset.round}_${input.dataset.player}`;
          if (state.scores[key] !== undefined) {
            input.value = state.scores[key];
          }
        });

        // All-of-the-Above per-rule grid
        const allHand = state.allHand || {};
        const allInputs = allRulesBody.querySelectorAll("input[data-all-rule]");
        allInputs.forEach((input) => {
          const r = input.dataset.allRule;
          const p = input.dataset.player;
          const val = allHand[r] && allHand[r][p];
          if (val !== undefined) {
            input.value = val;
          }
        });

        updateAllHandTotals();
        updateScores();
        updateSettingsInputsFromRounds();
      }

      /* ---------------------- Deck & Defaults ---------------------- */

      function applyDeckCountToDefaults() {
        rounds.forEach((round) => {
          if (round.defaultMaxCards != null) {
            round.maxCards = round.defaultMaxCards * deckCount;
          }
        });
      }

      function restoreDefaults() {
        applyDeckCountToDefaults();
        updateSettingsInputsFromRounds();
        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        updateScores();
        saveState();
      }

      /* ---------------------- Settings UI ---------------------- */

      function buildSettingsUI() {
        settingsGrid.innerHTML = "";

        rounds.forEach((round, idx) => {
          // No per-round max for the All-of-the-Above total row
          if (round.defaultMaxCards == null && round.maxCards == null) return;

          const labelDiv = document.createElement("div");
          labelDiv.className = "settings-round-label";
          labelDiv.innerHTML = `<span>${idx + 1}. ${round.name}</span>`;

          const input = document.createElement("input");
          input.type = "number";
          input.min = "0";
          input.step = "1";
          input.dataset.roundSettings = String(idx);
          input.value = round.maxCards != null
            ? round.maxCards
            : (round.defaultMaxCards != null ? round.defaultMaxCards * deckCount : 0);

          input.addEventListener("input", () => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            round.maxCards = val;
            input.value = String(val);
            enforceAllRoundLimits(idx);
            enforceAllHandLimitsForRule(idx);
            updateAllHandTotals();
            updateScores();
            saveState();
          });

          settingsGrid.appendChild(labelDiv);
          settingsGrid.appendChild(input);
        });
      }

      function updateSettingsInputsFromRounds() {
        const inputs = settingsGrid.querySelectorAll("input[type='number'][data-round-settings]");
        inputs.forEach((input) => {
          const idx = parseInt(input.dataset.roundSettings, 10);
          const round = rounds[idx];
          if (!round) return;
          if (round.maxCards != null) input.value = round.maxCards;
        });
      }

      /* ---------------------- UI Building ---------------------- */

      function clampPlayerCount(n) {
        if (isNaN(n)) return 4;
        return Math.min(Math.max(n, 2), 8);
      }

      function buildPlayerHeaders() {
        while (headerRow.children.length > 1) {
          headerRow.removeChild(headerRow.lastElementChild);
        }

        for (let p = 0; p < playerCount; p++) {
          const th = document.createElement("th");
          th.className = "player-header";
          th.dataset.player = String(p);

          const inner = document.createElement("div");
          inner.className = "player-header-inner";
          inner.style.background = `linear-gradient(135deg, ${hexToSoft(playerColors[p])}, ${playerColors[p]})`;

          const nameDiv = document.createElement("div");
          nameDiv.className = "player-name";
          nameDiv.textContent = "Player " + (p + 1);

          const totalDiv = document.createElement("div");
          totalDiv.className = "player-total";
          totalDiv.textContent = "0";

          inner.appendChild(nameDiv);
          inner.appendChild(totalDiv);
          th.appendChild(inner);
          headerRow.appendChild(th);
        }

        syncHeaderNamesFromSettings();
      }

      function buildRoundsBody() {
        roundsBody.innerHTML = "";

        rounds.forEach((round, rIndex) => {
          // Skip disabled rules for rounds 0..10
          if (rIndex < rounds.length - 1 && !includedRules[rIndex]) return;

          const tr = document.createElement("tr");

          const th = document.createElement("th");
          th.className = "round-header";

          const titleDiv = document.createElement("div");
          titleDiv.className = "round-title";

          const idxSpan = document.createElement("span");
          idxSpan.className = "round-index";
          idxSpan.textContent = String(rIndex + 1);

          const titleText = document.createElement("span");
          titleText.textContent = round.name;

          titleDiv.appendChild(idxSpan);
          titleDiv.appendChild(titleText);

          const descDiv = document.createElement("div");
          descDiv.className = "round-desc";
          descDiv.textContent = round.description;

          th.appendChild(titleDiv);
          th.appendChild(descDiv);

          const totalDiv = document.createElement("div");
          totalDiv.className = "round-total";
          totalDiv.dataset.round = String(rIndex);
          if (round.maxCards != null) {
            totalDiv.textContent = `0 / ${round.maxCards} cards`;
            totalDiv.classList.add("incomplete");
          } else {
            totalDiv.textContent = "";
          }
          th.appendChild(totalDiv);

          tr.appendChild(th);

          for (let p = 0; p < playerCount; p++) {
            const td = document.createElement("td");
            const wrapper = document.createElement("div");
            wrapper.className = "cell-input";

            const input = document.createElement("input");
            input.type = "number";
            input.min = "0";
            input.inputMode = "numeric";
            input.pattern = "[0-9]*";
            input.dataset.round = String(rIndex);
            input.dataset.player = String(p);

            const note = document.createElement("div");
            note.className = "cell-note";
            note.textContent = "0 pts";

            if (rIndex === rounds.length - 1) {
              // Round 12: total points from All-of-the-Above grid
              input.readOnly = true;
              input.addEventListener("focus", (e) => e.target.blur());
              wrapper.appendChild(input);
              wrapper.appendChild(note);
            } else {
              input.addEventListener("input", () => {
                enforceRoundLimitForInput(input);
                updateScores();
                saveState();
              });
              wrapper.appendChild(input);
              wrapper.appendChild(note);
            }

            td.appendChild(wrapper);
            tr.appendChild(td);
          }

          roundsBody.appendChild(tr);
        });
      }

      function buildAllHandGrid() {
        // Header
        while (allHeadRow.children.length > 1) {
          allHeadRow.removeChild(allHeadRow.lastElementChild);
        }
        const names = getCurrentPlayerNamesFromSettings();
        for (let p = 0; p < playerCount; p++) {
          const th = document.createElement("th");
          th.dataset.allPlayer = String(p);
          th.textContent = names[p] || `P${p + 1}`;
          allHeadRow.appendChild(th);
        }

        // Body
        allRulesBody.innerHTML = "";
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue; // skip disabled rules

          const round = rounds[rIndex];
          const tr = document.createElement("tr");

          const th = document.createElement("th");
          th.className = "round-header";
          th.innerHTML =
            `<div class="round-title">${rIndex + 1}. ${round.name}</div>` +
            `<div class="round-desc">×${round.pointsPerCard} pts</div>` +
            `<div class="round-total all-round-total" data-all-round="${rIndex}"></div>`;
          tr.appendChild(th);

          for (let p = 0; p < playerCount; p++) {
            const td = document.createElement("td");
            const wrapper = document.createElement("div");
            wrapper.className = "cell-input";

            const input = document.createElement("input");
            input.type = "number";
            input.min = "0";
            input.step = "1";
            input.inputMode = "numeric";
            input.pattern = "[0-9]*";
            input.dataset.allRule = String(rIndex);
            input.dataset.player = String(p);
            input.addEventListener("input", () => {
              enforceAllHandLimitForInput(input);
              updateAllHandTotals();
              saveState();
            });

            const note = document.createElement("div");
            note.className = "cell-note";
            note.textContent = "0 pts";

            wrapper.appendChild(input);
            wrapper.appendChild(note);
            td.appendChild(wrapper);
            tr.appendChild(td);
          }

          allRulesBody.appendChild(tr);
        }

        // Initialize the "X / N cards" indicators
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;
          const round = rounds[rIndex];
          const indicator = document.querySelector(`.all-round-total[data-all-round="${rIndex}"]`);
          if (!indicator || round.maxCards == null) continue;
          indicator.classList.remove("ok", "incomplete");
          indicator.textContent = `0 / ${round.maxCards} cards`;
          indicator.classList.add("incomplete");
        }
      }

      /* ---------------------- Card-limit Enforcement ---------------------- */

      function enforceRoundLimitForInput(input) {
        const rIndex = parseInt(input.dataset.round, 10);
        const round = rounds[rIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRound = roundsBody.querySelectorAll(
          `input[data-round="${rIndex}"]`
        );

        let sumOthers = 0;
        inputsThisRound.forEach((el) => {
          if (el === input) return;
          const v = parseInt(el.value || "0", 10);
          if (!isNaN(v) && v > 0) sumOthers += v;
        });

        let val = parseInt(input.value || "0", 10);
        if (isNaN(val) || val < 0) val = 0;

        const allowedForThis = Math.max(0, max - sumOthers);
        if (val > allowedForThis) {
          val = allowedForThis;
          input.value = val ? String(val) : "";
        }
      }

      function enforceAllRoundLimits(onlyRoundIndex = null) {
        const roundsToCheck =
          onlyRoundIndex == null
            ? rounds.map((_, idx) => idx)
            : [onlyRoundIndex];

        roundsToCheck.forEach((rIndex) => {
          const round = rounds[rIndex];
          if (!round || round.maxCards == null) return;

          const max = round.maxCards;
          const inputsThisRound = roundsBody.querySelectorAll(
            `input[data-round="${rIndex}"]`
          );

          let total = 0;
          inputsThisRound.forEach((input) => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            total += val;
          });

          if (total <= max) return;

          let remaining = max;
          inputsThisRound.forEach((input) => {
            let val = parseInt(input.value || "0", 10);
            if (isNaN(val) || val < 0) val = 0;
            if (val > remaining) {
              val = remaining;
            }
            input.value = val ? String(val) : "";
            remaining -= val;
          });
        });
      }

      // All-of-the-Above per-rule grid limits
      function enforceAllHandLimitForInput(input) {
        const rIndex = parseInt(input.dataset.allRule, 10);
        const round = rounds[rIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRule = allRulesBody.querySelectorAll(
          `input[data-all-rule="${rIndex}"]`
        );

        let sumOthers = 0;
        inputsThisRule.forEach((el) => {
          if (el === input) return;
          const v = parseInt(el.value || "0", 10);
          if (!isNaN(v) && v > 0) sumOthers += v;
        });

        let val = parseInt(input.value || "0", 10);
        if (isNaN(val) || val < 0) val = 0;

        const allowedForThis = Math.max(0, max - sumOthers);
        if (val > allowedForThis) {
          val = allowedForThis;
          input.value = val ? String(val) : "";
        }
      }

      function enforceAllHandLimitsForRule(ruleIndex) {
        const round = rounds[ruleIndex];
        if (!round || round.maxCards == null) return;

        const max = round.maxCards;
        const inputsThisRule = allRulesBody.querySelectorAll(
          `input[data-all-rule="${ruleIndex}"]`
        );

        let total = 0;
        inputsThisRule.forEach((input) => {
          let val = parseInt(input.value || "0", 10);
          if (isNaN(val) || val < 0) val = 0;
          total += val;
        });

        if (total <= max) return;

        let remaining = max;
        inputsThisRule.forEach((input) => {
          let val = parseInt(input.value || "0", 10);
          if (isNaN(val) || val < 0) val = 0;
          if (val > remaining) {
            val = remaining;
          }
          input.value = val ? String(val) : "";
          remaining -= val;
        });
      }

      function enforceAllHandLimitsForAll() {
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          enforceAllHandLimitsForRule(rIndex);
        }
      }

      /* ---------------------- Score Logic ---------------------- */

      function resetScores() {
        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");
        inputs.forEach((input) => {
          input.value = "";
        });

        const notes = scoreTable.querySelectorAll(".cell-note");
        notes.forEach((n) => {
          n.textContent = "0 pts";
          n.classList.remove("highlight");
        });

        // All-of-the-Above grid
        const allInputs = allRulesBody.querySelectorAll("input[data-all-rule]");
        allInputs.forEach((input) => {
          input.value = "";
        });
        const allNotes = allRulesBody.querySelectorAll(".cell-note");
        allNotes.forEach((n) => {
          n.textContent = "0 pts";
          n.classList.remove("highlight");
        });
        updateAllHandTotals();

        const totals = scoreTable.querySelectorAll(".player-total");
        totals.forEach((t) => (t.textContent = "0"));

        const headers = scoreTable.querySelectorAll(".player-header-inner");
        headers.forEach((h) => h.classList.remove("winner"));

        const totalEls = document.querySelectorAll(".round-total[data-round]");
        totalEls.forEach((el) => {
          const rIndex = parseInt(el.dataset.round || "-1", 10);
          const round = rounds[rIndex];
          el.classList.remove("ok", "incomplete");
          if (round && round.maxCards != null) {
            el.textContent = `0 / ${round.maxCards} cards`;
            el.classList.add("incomplete");
          } else {
            if (round && round.pointsPerCard === null) {
              el.textContent = "";
            }
          }
        });

        localStorage.removeItem(STORAGE_KEY);
      }

      function updateScores() {
        const totals = new Array(playerCount).fill(0);
        const roundSums = new Array(rounds.length).fill(0);

        const inputs = scoreTable.querySelectorAll("tbody input[type='number']");

        inputs.forEach((input) => {
          const r = parseInt(input.dataset.round, 10);
          const p = parseInt(input.dataset.player, 10);
          const round = rounds[r];
          const count = parseInt(input.value || "0", 10) || 0;

          if (!isNaN(count) && count > 0 && round.maxCards != null) {
            roundSums[r] += count;
          }

          let points = 0;
          if (round.pointsPerCard === null) {
            // Round 12: value is already total points
            points = count;
          } else {
            points = count * round.pointsPerCard;
          }

          totals[p] += points;

          const note = input.parentElement.querySelector(".cell-note");
          if (note) {
            note.textContent = points + " pts";
            note.classList.toggle("highlight", points > 0);
          }
        });

        updateRoundTotals(roundSums);

        const totalNodes = document.querySelectorAll(".player-total");
        const headers = document.querySelectorAll(".player-header-inner");

        totalNodes.forEach((node, idx) => {
          node.textContent = totals[idx];
        });

        headers.forEach((h) => h.classList.remove("winner"));

        const anyNonZero = totals.some((v) => v !== 0);
        if (anyNonZero) {
          const minTotal = Math.min(...totals);
          totals.forEach((t, idx) => {
            if (t === minTotal) {
              headers[idx].classList.add("winner");
            }
          });
        }
      }

      function updateRoundTotals(roundSums) {
        roundSums.forEach((sum, rIndex) => {
          const round = rounds[rIndex];
          const el = document.querySelector(`.round-total[data-round="${rIndex}"]`);
          if (!el || !round) return;

          el.classList.remove("ok", "incomplete");

          if (round.maxCards == null) {
            el.textContent = "";
            return;
          }

          el.textContent = `${sum} / ${round.maxCards} cards`;

          if (sum === round.maxCards) {
            el.classList.add("ok");
          } else {
            el.classList.add("incomplete");
          }
        });
      }

      // Compute Round 12 totals + All-of-the-Above indicators
      function updateAllHandTotals() {
        const totalsByPlayer = new Array(playerCount).fill(0);
        const ruleTotals = new Array(rounds.length - 1).fill(0);

        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;

          const rule = rounds[rIndex];
          const inputsThisRule = allRulesBody.querySelectorAll(
            `input[data-all-rule="${rIndex}"]`
          );

          inputsThisRule.forEach((input) => {
            const p = parseInt(input.dataset.player, 10);
            const cnt = parseInt(input.value || "0", 10) || 0;
            const pts = cnt * (rule.pointsPerCard || 0);
            totalsByPlayer[p] += pts;
            ruleTotals[rIndex] += cnt;

            const note = input.parentElement.querySelector(".cell-note");
            if (note) {
              note.textContent = pts + " pts";
              note.classList.toggle("highlight", pts > 0);
            }
          });
        }

        // Update "X / N cards" per rule row in All-of-the-Above grid
        for (let rIndex = 0; rIndex < rounds.length - 1; rIndex++) {
          if (!includedRules[rIndex]) continue;
          const round = rounds[rIndex];
          const indicator = document.querySelector(`.all-round-total[data-all-round="${rIndex}"]`);
          if (!indicator || round.maxCards == null) continue;
          indicator.classList.remove("ok", "incomplete");
          indicator.textContent = `${ruleTotals[rIndex]} / ${round.maxCards} cards`;
          if (ruleTotals[rIndex] === round.maxCards) {
            indicator.classList.add("ok");
          } else {
            indicator.classList.add("incomplete");
          }
        }

        // Push totals into Round 12 row
        const allRowIndex = rounds.length - 1;
        for (let p = 0; p < playerCount; p++) {
          const mainInput = document.querySelector(
            `input[data-round="${allRowIndex}"][data-player="${p}"]`
          );
          if (mainInput) {
            const total = totalsByPlayer[p];
            mainInput.value = total ? String(total) : "";
          }
        }

        updateScores();
      }

      /* ---------------------- Utility ---------------------- */

      function hexToSoft(hex) {
        const base = "#1d4ed8";
        try {
          const c1 = hexToRgb(hex);
          const c2 = hexToRgb(base);
          const mix = {
            r: Math.round((c1.r + c2.r * 1.4) / 2.4),
            g: Math.round((c1.g + c2.g * 1.4) / 2.4),
            b: Math.round((c1.b + c2.b * 1.4) / 2.4)
          };
          return `rgba(${mix.r},${mix.g},${mix.b},0.6)`;
        } catch {
          return "rgba(30,64,175,0.55)";
        }
      }

      function hexToRgb(hex) {
        const c = hex.replace("#", "");
        if (c.length !== 6) return null;
        const v = parseInt(c, 16);
        return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
      }

      /* ---------------------- Event Setup ---------------------- */

      buildBtn.addEventListener("click", () => {
        const desired = clampPlayerCount(parseInt(playerCountInput.value, 10));
        const existingNames = getCurrentPlayerNamesFromSettings();
        playerCount = desired;
        playerCountInput.value = desired;

        buildPlayerHeaders();
        buildRoundsBody();
        buildSettingsUI();
        buildRulesUI();
        buildAllHandGrid();
        buildPlayerNameInputs(existingNames);
        updateCardRemovalHint();

        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        saveState();
      });

      resetBtn.addEventListener("click", resetScores);

      restoreDefaultsBtn.addEventListener("click", () => {
        restoreDefaults();
      });

      deckCountSelect.addEventListener("change", () => {
        const dc = parseInt(deckCountSelect.value, 10);
        deckCount = !isNaN(dc) && dc >= 1 ? dc : 1;
        applyDeckCountToDefaults();
        updateSettingsInputsFromRounds();
        enforceAllRoundLimits();
        enforceAllHandLimitsForAll();
        updateAllHandTotals();
        updateScores();
        updateCardRemovalHint();
        saveState();
      });

      toggleSettingsBtn.addEventListener("click", () => {
        const nowHidden = settingsCardEl.classList.toggle("hidden");
        toggleSettingsBtn.textContent = nowHidden ? "Show Settings" : "Hide Settings";
      });

      toggleAllDetailsBtn.addEventListener("click", () => {
        const nowHidden = allDetailsCard.classList.toggle("hidden");
        toggleAllDetailsBtn.textContent = nowHidden
          ? "Show All-of-the-Above Grid"
          : "Hide All-of-the-Above Grid";
      });

      /* ---------------------- Initial Load ---------------------- */

      applyDeckCountToDefaults();
      buildPlayerHeaders();
      buildRoundsBody();
      buildSettingsUI();
      buildRulesUI();
      buildAllHandGrid();
      buildPlayerNameInputs(); // default names
      updateCardRemovalHint();

      const saved = loadState();
      applyLoadedState(saved);

    })();
  </script>
</body>
</html>
